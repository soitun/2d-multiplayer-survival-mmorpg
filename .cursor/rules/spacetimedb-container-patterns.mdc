---
description: Safe container-processing patterns for wooden_storage_box, compost, and refrigerator reducers
globs: server/src/{wooden_storage_box,compost,refrigerator}.rs
alwaysApply: false
---
# SpacetimeDB Container Processing Patterns

Use this when implementing or editing reducers that process box/container contents (compost, refrigerator-like systems, scheduled item conversion, etc.).

Primary reference files:
- `server/src/wooden_storage_box.rs`
- `server/src/compost.rs`
- `server/src/refrigerator.rs`

## Problem to Avoid

Complex borrow graphs across multiple table handles in nested loops can trigger Rust type-check blowups/panics in SpacetimeDB-generated table types.

Typical risky shape:
- Hold `wooden_storage_box`, `inventory_item`, and `item_definition` table handles together
- Iterate containers and slots while calling nested `.find()` / `.iter()` chains

## Preferred Pattern (Project Standard)

### Phase 1: Collect IDs only

```rust
let container_ids: Vec<u32> = {
    let boxes = ctx.db.wooden_storage_box();
    let mut ids = Vec::new();
    for b in boxes.iter() {
        if b.box_type == BOX_TYPE_COMPOST {
            ids.push(b.id);
        }
    }
    ids
}; // borrow ends
```

### Phase 2: Process one container at a time

```rust
for id in container_ids {
    let _ = process_single_container(ctx, id);
}
```

### Phase 3: Fresh handles inside helper

```rust
fn process_single_container(ctx: &ReducerContext, id: u32) -> Result<(), String> {
    let boxes = ctx.db.wooden_storage_box();
    let items = ctx.db.inventory_item();
    let defs = ctx.db.item_definition();
    // ...
    Ok(())
}
```

## Rules of Thumb

1. Keep table-handle lifetimes short with explicit scopes.
2. Prefer manual `for` loops over dense iterator/closure chains in hot reducer logic.
3. Use explicit type annotations (`Vec<u32>`, etc.) when inference gets complex.
4. Separate read/collect phase from mutate/update phase.
5. Re-fetch before update if data may have changed during processing.

## Container-Specific Notes for This Repo

- Box behavior is keyed by `box_type` constants in `wooden_storage_box.rs`.
- Slot access uses per-slot fields and helper methods; respect `num_slots()` per box type.
- For scheduled processors, enforce scheduler-only invocation:

```rust
if ctx.sender != ctx.identity() {
    return Err("Can only be called by scheduler".to_string());
}
```

## Checklist Before Shipping

- [ ] No long-lived multi-table borrows across nested loops
- [ ] ID collection is isolated from mutation
- [ ] Helper function uses fresh table handles
- [ ] Slot bounds/box type logic matches `wooden_storage_box.rs`
- [ ] Scheduled reducers validate `ctx.sender == ctx.identity()`
