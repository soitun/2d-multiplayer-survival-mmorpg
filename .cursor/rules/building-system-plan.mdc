# Building System Implementation Plan

## Overview
Building a Rust-style building system (foundations, walls, doors) integrated with our existing multiplayer survival game architecture.

## Architecture Decisions

### 1. **Cell System**
- **1 cell = 1 tile** (48px × 48px) for simplicity and alignment with existing tile system
- Cell coordinates use tile coordinates directly: `cell_x = tile_x`, `cell_y = tile_y`
- No need for separate cell-to-tile conversion

### 2. **Coordinate System**
- Use existing `world_pos_to_tile_coords()` from `lib.rs` (line 319)
- Building pieces snap to tile grid (48px increments)
- World coordinates → Tile coordinates → Cell coordinates (1:1 mapping)

### 3. **Integration Points**
- **Repair Hammer**: Already exists in `repair.rs` - extend to support building pieces
- **Combat System**: Extend `combat.rs` to handle building piece damage
- **Placement System**: Extend `usePlacementManager.ts` for building mode
- **Rendering**: New renderers integrated into Y-sorted system (`renderingUtils.ts`)

## Server-Side Implementation

### Phase 1: Core Data Structures (`server/src/building.rs`)

#### Tables
```rust
// Foundation cells (like Rust foundations)
#[spacetimedb::table(name = foundation_cell, public)]
pub struct FoundationCell {
    #[primary_key]
    #[auto_inc]
    pub id: u64,
    pub cell_x: i32,  // Tile X coordinate
    pub cell_y: i32,  // Tile Y coordinate
    pub chunk_index: u32,  // For chunk-based queries
    pub shape: u8,    // FoundationShape enum
    pub tier: u8,     // Tier enum (Wood=0, Stone=1, Metal=2)
    pub health: f32,
    pub max_health: f32,
    pub owner: Identity,
    pub placed_at: Timestamp,
    pub is_destroyed: bool,
    pub destroyed_at: Option<Timestamp>,
    pub last_hit_time: Option<Timestamp>,
    pub last_damaged_by: Option<Identity>,
    pub group_id: Option<i64>,  // For future building groups/clans
}

// Walls placed on cell edges
#[spacetimedb::table(name = wall, public)]
pub struct Wall {
    #[primary_key]
    #[auto_inc]
    pub id: u64,
    pub cell_x: i32,
    pub cell_y: i32,
    pub edge: u8,        // Edge enum (N=0, E=1, S=2, W=3, DiagNE_SW=4, DiagNW_SE=5)
    pub facing: u8,      // Facing enum (Interior=0, Exterior=1)
    pub tier: u8,
    pub health: f32,
    pub max_health: f32,
    pub owner: Identity,
    pub placed_at: Timestamp,
    pub is_destroyed: bool,
    pub destroyed_at: Option<Timestamp>,
    pub last_hit_time: Option<Timestamp>,
    pub last_damaged_by: Option<Identity>,
    pub group_id: Option<i64>,
    pub chunk_index: u32,
}

// Doorframe replaces a wall
#[spacetimedb::table(name = door_frame, public)]
pub struct DoorFrame {
    #[primary_key]
    #[auto_inc]
    pub id: u64,
    pub wall_id: u64,  // Original wall this replaces
    pub cell_x: i32,
    pub cell_y: i32,
    pub edge: u8,
    pub facing: u8,
    pub tier: u8,
    pub health: f32,
    pub max_health: f32,
    pub owner: Identity,
    pub placed_at: Timestamp,
    pub is_destroyed: bool,
    pub destroyed_at: Option<Timestamp>,
    pub last_hit_time: Option<Timestamp>,
    pub last_damaged_by: Option<Identity>,
    pub group_id: Option<i64>,
    pub chunk_index: u32,
}

// Door inserted into a frame
#[spacetimedb::table(name = door, public)]
pub struct Door {
    #[primary_key]
    #[auto_inc]
    pub id: u64,
    pub frame_id: u64,
    pub facing: u8,
    pub is_open: bool,
    pub locked: bool,
    pub code: Option<u32>,
    pub tier: u8,
    pub health: f32,
    pub max_health: f32,
    pub owner: Identity,
    pub placed_at: Timestamp,
    pub is_destroyed: bool,
    pub destroyed_at: Option<Timestamp>,
    pub last_hit_time: Option<Timestamp>,
    pub last_damaged_by: Option<Identity>,
    pub group_id: Option<i64>,
}

// Build chunk versioning for client updates
#[spacetimedb::table(name = build_chunk, public)]
pub struct BuildChunk {
    #[primary_key]
    pub chunk_x: i32,
    pub chunk_y: i32,
    pub version: i64,  // Incremented on any change
    pub updated_at: Timestamp,
}
```

#### Enums (add to `server/src/models.rs`)
```rust
#[derive(SpacetimeType, Clone, Copy, Debug, PartialEq)]
#[repr(u8)]
pub enum FoundationShape {
    Empty = 0,
    Full = 1,
    TriNW = 2,  // Triangle pointing NW
    TriNE = 3,  // Triangle pointing NE
    TriSE = 4,  // Triangle pointing SE
    TriSW = 5,  // Triangle pointing SW
}

#[derive(SpacetimeType, Clone, Copy, Debug, PartialEq)]
#[repr(u8)]
pub enum BuildingEdge {
    N = 0,      // North (top)
    E = 1,      // East (right)
    S = 2,      // South (bottom)
    W = 3,      // West (left)
    DiagNE_SW = 4,  // Diagonal NE-SW (only for triangles)
    DiagNW_SE = 5,  // Diagonal NW-SE (only for triangles)
}

#[derive(SpacetimeType, Clone, Copy, Debug, PartialEq)]
#[repr(u8)]
pub enum BuildingFacing {
    Interior = 0,
    Exterior = 1,
}

#[derive(SpacetimeType, Clone, Copy, Debug, PartialEq)]
#[repr(u8)]
pub enum BuildingTier {
    Wood = 0,
    Stone = 1,
    Metal = 2,
}

// Add to TargetType enum
pub enum TargetType {
    // ... existing variants ...
    Foundation,
    Wall,
    DoorFrame,
    Door,
}
```

### Phase 2: Reducers (`server/src/building.rs`)

#### Core Placement Reducers
```rust
// Place foundation cell
#[spacetimedb::reducer]
pub fn place_foundation(
    ctx: &ReducerContext,
    cell_x: i32,
    cell_y: i32,
    shape: u8,
    tier: u8,
) -> Result<u64, String>;  // Returns foundation ID

// Remove foundation (and cascade delete walls/doors)
#[spacetimedb::reducer]
pub fn remove_foundation(
    ctx: &ReducerContext,
    foundation_id: u64,
) -> Result<(), String>;

// Place wall on cell edge
#[spacetimedb::reducer]
pub fn place_wall(
    ctx: &ReducerContext,
    cell_x: i32,
    cell_y: i32,
    edge: u8,
    facing: u8,
    tier: u8,
) -> Result<u64, String>;  // Returns wall ID

// Replace wall with doorframe
#[spacetimedb::reducer]
pub fn replace_wall_with_doorframe(
    ctx: &ReducerContext,
    wall_id: u64,
    facing: u8,
    tier: u8,
) -> Result<u64, String>;  // Returns doorframe ID

// Place door in doorframe
#[spacetimedb::reducer]
pub fn place_door(
    ctx: &ReducerContext,
    frame_id: u64,
    facing: u8,
    tier: u8,
    locked: bool,
    code: Option<u32>,
) -> Result<u64, String>;  // Returns door ID

// Toggle door open/closed
#[spacetimedb::reducer]
pub fn toggle_door(
    ctx: &ReducerContext,
    door_id: u64,
    code: Option<u32>,
) -> Result<bool, String>;  // Returns new is_open state

// Upgrade building piece (foundation/wall/doorframe/door)
#[spacetimedb::reducer]
pub fn upgrade_building_piece(
    ctx: &ReducerContext,
    piece_kind: u8,  // 0=Foundation, 1=Wall, 2=DoorFrame, 3=Door
    piece_id: u64,
    to_tier: u8,
) -> Result<(), String>;

// Destroy building piece
#[spacetimedb::reducer]
pub fn destroy_building_piece(
    ctx: &ReducerContext,
    piece_kind: u8,
    piece_id: u64,
) -> Result<(), String>;

// Damage building piece (called by combat system)
#[spacetimedb::reducer]
pub fn damage_building_piece(
    ctx: &ReducerContext,
    piece_kind: u8,
    piece_id: u64,
    amount: f32,
) -> Result<(), String>;
```

#### Validation Logic
- **Hammer Check**: All reducers validate Repair Hammer equipped (reuse `repair.rs` logic)
- **Foundation Rules**: 
  - Shape must be valid enum value
  - No overlapping foundations at same cell
  - Triangle foundations can merge into Full if complementary
- **Wall Rules**:
  - Edge must be valid for foundation shape
  - Cardinal edges: at least one adjacent cell has foundation
  - Diagonal edges: only on triangle foundations
  - One piece per edge slot (wall OR doorframe+door)
- **Doorframe Rules**: Must replace existing wall
- **Door Rules**: Must target existing doorframe, only one door per frame

### Phase 3: Integration Points

#### Extend `repair.rs`
```rust
// Add building piece repair functions
pub fn repair_foundation(...) -> Result<AttackResult, String>;
pub fn repair_wall(...) -> Result<AttackResult, String>;
pub fn repair_doorframe(...) -> Result<AttackResult, String>;
pub fn repair_door(...) -> Result<AttackResult, String>;

// Extend get_structure_item_name()
match target_type {
    TargetType::Foundation => "Foundation",
    TargetType::Wall => "Wall",
    TargetType::DoorFrame => "Door Frame",
    TargetType::Door => "Door",
    // ... existing
}
```

#### Extend `combat.rs`
- Add building piece damage handlers
- Add building pieces to `is_destructible_deployable()`
- Handle building piece destruction (cascade to walls/doors)

#### Extend `lib.rs`
```rust
mod building;  // Add module declaration
pub use building::{
    place_foundation, remove_foundation,
    place_wall, replace_wall_with_doorframe,
    place_door, toggle_door,
    upgrade_building_piece, destroy_building_piece,
    damage_building_piece,
};
```

## Client-Side Implementation

### Phase 1: Building Mode Hook (`client/src/hooks/useBuildingManager.ts`)

New hook similar to `usePlacementManager.ts`:
```typescript
export interface BuildingState {
  isBuilding: boolean;
  buildMode: 'foundation' | 'wall' | 'doorframe' | 'door' | null;
  foundationShape: FoundationShape;
  buildingTier: BuildingTier;
  buildingFacing: BuildingFacing;
  selectedCell: { x: number; y: number } | null;
  selectedEdge: BuildingEdge | null;
}

export interface BuildingActions {
  enterBuildMode: (mode: BuildingMode) => void;
  exitBuildMode: () => void;
  cycleFoundationShape: () => void;
  toggleFacing: () => void;
  attemptPlacement: (worldX: number, worldY: number) => void;
  attemptUpgrade: (pieceKind: PieceKind, pieceId: bigint) => void;
  attemptDestroy: (pieceKind: PieceKind, pieceId: bigint) => void;
}
```

### Phase 2: Placement Integration (`client/src/hooks/usePlacementManager.ts`)

Add building piece cases to `attemptPlacement()`:
```typescript
case 'Foundation':
  connection.reducers.placeFoundation(cellX, cellY, shape, tier);
  break;
case 'Wall':
  connection.reducers.placeWall(cellX, cellY, edge, facing, tier);
  break;
// ... etc
```

### Phase 3: Rendering (`client/src/utils/renderers/`)

#### New Files:
- `foundationRenderingUtils.ts` - Render foundation cells
- `wallRenderingUtils.ts` - Render walls on edges
- `doorRenderingUtils.ts` - Render doors and doorframes
- `buildingPreviewUtils.ts` - Ghost preview for placement

#### Integration Points:
- Add to `renderingUtils.ts` Y-sorted entities
- Add to `placementRenderingUtils.ts` for preview rendering
- Use existing sprite system and image loading

### Phase 4: Building Preview (`client/src/utils/renderers/buildingPreviewUtils.ts`)

```typescript
export function renderBuildingPreview({
  ctx,
  buildMode,
  worldMouseX,
  worldMouseY,
  foundationShape,
  buildingTier,
  buildingFacing,
  selectedEdge,
  connection,
}: BuildingPreviewParams): void {
  // Convert world coords to cell coords
  const { tileX, tileY } = worldPosToTileCoords(worldMouseX, worldMouseY);
  
  // Validate placement (check foundations, edges, etc.)
  const isValid = validateBuildingPlacement(connection, buildMode, tileX, tileY, selectedEdge);
  
  // Render ghost preview (green if valid, red if invalid)
  // ... rendering logic
}
```

## Implementation Order

### Step 1: Server Foundation (Week 1)
1. Create `server/src/building.rs` with tables and enums
2. Implement `place_foundation()` reducer
3. Add to `lib.rs` module declarations
4. Test foundation placement via SQL/CLI

### Step 2: Server Walls (Week 1-2)
1. Implement `place_wall()` reducer
2. Implement edge validation logic
3. Test wall placement and edge validation

### Step 3: Server Doors (Week 2)
1. Implement `replace_wall_with_doorframe()` reducer
2. Implement `place_door()` and `toggle_door()` reducers
3. Test door placement and toggling

### Step 4: Server Damage/Repair (Week 2-3)
1. Extend `combat.rs` for building damage
2. Extend `repair.rs` for building repair
3. Implement `upgrade_building_piece()` and `destroy_building_piece()`
4. Test damage, repair, upgrade, destroy

### Step 5: Client Building Mode (Week 3)
1. Create `useBuildingManager.ts` hook
2. Add building mode UI (radial menu or hotkeys)
3. Integrate with existing placement system

### Step 6: Client Rendering (Week 3-4)
1. Create foundation renderer
2. Create wall renderer
3. Create door renderer
4. Add to Y-sorted rendering system
5. Add building preview system

### Step 7: Polish & Integration (Week 4)
1. Add building piece collision detection
2. Add building piece interaction outlines
3. Test multiplayer building
4. Performance optimization

## Key Constants

```rust
// Building health (per tier)
pub const FOUNDATION_WOOD_MAX_HEALTH: f32 = 500.0;
pub const FOUNDATION_STONE_MAX_HEALTH: f32 = 1000.0;
pub const FOUNDATION_METAL_MAX_HEALTH: f32 = 2000.0;

pub const WALL_WOOD_MAX_HEALTH: f32 = 250.0;
pub const WALL_STONE_MAX_HEALTH: f32 = 500.0;
pub const WALL_METAL_MAX_HEALTH: f32 = 1000.0;

// Building costs (from items database)
// Will be pulled from ItemDefinition.crafting_cost for each tier

// Placement distance
pub const BUILDING_PLACEMENT_MAX_DISTANCE: f32 = 128.0;  // Same as other structures
```

## Notes

- **Chunk System**: Use existing `chunk_index` calculation from `environment.rs`
- **Ownership**: Follow existing pattern (owner = `placed_by`)
- **Group System**: `group_id` for future clan/base sharing (optional for now)
- **Collision**: Building pieces block movement (walls block unless door is open)
- **Nav Mesh**: Update `BuildChunk.version` when pieces change for NPC pathfinding
