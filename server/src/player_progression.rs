/******************************************************************************
 *                                                                            *
 * Player Progression System - XP, Levels, Achievements, Leaderboards         *
 *                                                                            *
 * Handles all player engagement systems including:                           *
 * - XP and leveling system                                                  *
 * - Achievement tracking and unlocking                                      *
 * - Daily login rewards and streaks                                         *
 * - Player titles/badges                                                    *
 * - Leaderboards                                                            *
 * - Progress notifications                                                  *
 * - Comparative statistics                                                  *
 *                                                                            *
 ******************************************************************************/

use spacetimedb::{Identity, Timestamp, ReducerContext, Table, SpacetimeType};
use log;

// Import table traits (auto-generated by SpacetimeDB)
use crate::player_progression::player_stats as PlayerStatsTableTrait;
use crate::player_progression::achievement_definition as AchievementDefinitionTableTrait;
use crate::player_progression::player_achievement as PlayerAchievementTableTrait;
use crate::player_progression::daily_login_reward as DailyLoginRewardTableTrait;
use crate::player_progression::achievement_unlock_notification as AchievementUnlockNotificationTableTrait;
use crate::player_progression::level_up_notification as LevelUpNotificationTableTrait;
use crate::player_progression::daily_login_notification as DailyLoginNotificationTableTrait;
use crate::player_progression::progress_notification as ProgressNotificationTableTrait;
use crate::player_progression::comparative_stat_notification as ComparativeStatNotificationTableTrait;
use crate::player_progression::leaderboard_entry as LeaderboardEntryTableTrait;
use crate::dropped_item::give_item_to_player_or_drop;
use crate::items::item_definition as ItemDefinitionTableTrait;
use crate::world_state::world_state as WorldStateTableTrait;
use crate::player as PlayerTableTrait;

// ============================================================================
// CONSTANTS
// ============================================================================

// XP Formula: 100 * level^1.5
pub fn xp_for_level(level: u32) -> u64 {
    (100.0 * (level as f64).powf(1.5)) as u64
}

// XP Sources (tuned for engagement)
pub const XP_FISH_CAUGHT: u64 = 10;
pub const XP_CAIRN_DISCOVERED: u64 = 50;
pub const XP_CONTRACT_COMPLETED: u64 = 25;
pub const XP_ITEM_CRAFTED: u64 = 5;
pub const XP_TREE_CHOPPED: u64 = 2;
pub const XP_STONE_MINED: u64 = 2;
pub const XP_ANIMAL_KILLED: u64 = 15;
pub const XP_SURVIVAL_MINUTE: u64 = 1;
pub const XP_CORAL_HARVESTED: u64 = 3;    // Underwater coral mining
pub const XP_PLANT_HARVESTED: u64 = 2;    // Picking wild plants/berries
pub const XP_CROP_HARVESTED: u64 = 1;     // Farming planted crops (slightly less)

// Progress notification thresholds (as percentages)
pub const PROGRESS_THRESHOLD_50: f32 = 0.5;
pub const PROGRESS_THRESHOLD_75: f32 = 0.75;
pub const PROGRESS_THRESHOLD_90: f32 = 0.9;

// ============================================================================
// ENUMS
// ============================================================================

#[derive(SpacetimeType, Clone, Debug, PartialEq, Eq)]
pub enum AchievementCategory {
    Exploration,
    Combat,
    Crafting,
    Survival,
    Social,
    Collection,
}

#[derive(SpacetimeType, Clone, Debug, PartialEq, Eq)]
pub enum ProgressType {
    Level,
    Achievement,
    Contract,
    Cairn,
}

#[derive(SpacetimeType, Clone, Debug, PartialEq, Eq)]
pub enum LeaderboardCategory {
    ShardsEarned,
    LongestSurvival,
    ContractsCompleted,
    FishCaught,
    CairnsDiscovered,
    Level,
}

// ============================================================================
// TABLES
// ============================================================================

/// PlayerStats - XP, level, and aggregate tracking
#[spacetimedb::table(
    name = player_stats,
    public,
    index(name = idx_level, btree(columns = [level])),
    index(name = idx_total_shards, btree(columns = [total_shards_earned])),
    index(name = idx_survival_time, btree(columns = [longest_survival_seconds]))
)]
#[derive(Clone, Debug)]
pub struct PlayerStats {
    #[primary_key]
    pub player_id: Identity,
    pub total_xp: u64,
    pub level: u32,
    pub xp_to_next_level: u64,
    
    // Aggregate stats for achievements/leaderboards
    pub fish_caught: u32,
    pub animals_killed: u32,
    pub cairns_discovered: u32,
    pub contracts_completed: u32,
    pub items_crafted: u32,
    pub trees_chopped: u32,
    pub stones_mined: u32,
    pub corals_mined: u32,        // NEW: Underwater coral mining
    pub plants_harvested: u32,    // NEW: Foraging wild plants
    pub deaths: u32,
    pub play_time_seconds: u64,
    pub longest_survival_seconds: u64,
    pub current_survival_start: Option<Timestamp>, // When current survival run started
    pub total_shards_earned: u64,
    
    pub last_login_day: u32,        // For daily rewards (world day number)
    pub login_streak_days: u32,     // For streaks
    pub active_title_id: Option<String>,
    pub updated_at: Timestamp,
}

/// AchievementDefinition - seeded at init
#[spacetimedb::table(name = achievement_definition, public)]
#[derive(Clone, Debug)]
pub struct AchievementDefinition {
    #[primary_key]
    pub id: String,  // e.g., "first_cairn", "fish_100"
    pub name: String,
    pub description: String,
    pub icon: String,
    pub xp_reward: u64,
    pub title_reward: Option<String>,
    pub category: AchievementCategory,
}

/// PlayerAchievement - unlocked achievements per player
#[spacetimedb::table(
    name = player_achievement,
    public,
    index(name = idx_player_achievements, btree(columns = [player_id]))
)]
#[derive(Clone, Debug)]
pub struct PlayerAchievement {
    #[primary_key]
    #[auto_inc]
    pub id: u64,
    pub player_id: Identity,
    pub achievement_id: String,
    pub unlocked_at: Timestamp,
}

/// DailyLoginReward - reward tier definitions
#[spacetimedb::table(name = daily_login_reward, public)]
#[derive(Clone, Debug)]
pub struct DailyLoginReward {
    #[primary_key]
    pub day: u32,  // 1-7, then loops
    pub shard_reward: u64,
    pub bonus_xp: u64,
}

/// AchievementUnlockNotification - sent to client for toast notifications
#[spacetimedb::table(name = achievement_unlock_notification, public)]
#[derive(Clone, Debug)]
pub struct AchievementUnlockNotification {
    #[primary_key]
    #[auto_inc]
    pub id: u64,
    pub player_id: Identity,
    pub achievement_id: String,
    pub achievement_name: String,
    pub xp_awarded: u64,
    pub title_awarded: Option<String>,
    pub unlocked_at: Timestamp,
}

/// LevelUpNotification - sent to client when player levels up
#[spacetimedb::table(name = level_up_notification, public)]
#[derive(Clone, Debug)]
pub struct LevelUpNotification {
    #[primary_key]
    #[auto_inc]
    pub id: u64,
    pub player_id: Identity,
    pub new_level: u32,
    pub xp_awarded: u64,
    pub unlocked_at: Timestamp,
}

/// DailyLoginNotification - sent to client for daily reward display
#[spacetimedb::table(
    name = daily_login_notification,
    public,
    index(name = idx_player_daily, btree(columns = [player_id]))
)]
#[derive(Clone, Debug)]
pub struct DailyLoginNotification {
    #[primary_key]
    #[auto_inc]
    pub id: u64,
    pub player_id: Identity,
    pub day: u32,
    pub shard_reward: u64,
    pub bonus_xp: u64,
    pub streak_days: u32,
    pub unlocked_at: Timestamp,
}

/// ProgressNotification - threshold-based progress updates
#[spacetimedb::table(
    name = progress_notification,
    public,
    index(name = idx_player_progress, btree(columns = [player_id]))
)]
#[derive(Clone, Debug)]
pub struct ProgressNotification {
    #[primary_key]
    #[auto_inc]
    pub id: u64,
    pub player_id: Identity,
    pub message: String,
    pub progress_type: ProgressType,
    pub current_value: u64,
    pub target_value: u64,
    pub progress_percent: f32,
    pub created_at: Timestamp,
}

/// ComparativeStatNotification - percentile-based stats on death
#[spacetimedb::table(name = comparative_stat_notification, public)]
#[derive(Clone, Debug)]
pub struct ComparativeStatNotification {
    #[primary_key]
    #[auto_inc]
    pub id: u64,
    pub player_id: Identity,
    pub stat_name: String,
    pub player_value: u64,
    pub percentile: f32,
    pub message: String,
    pub created_at: Timestamp,
}

/// LeaderboardEntry - computed leaderboard entries
#[spacetimedb::table(
    name = leaderboard_entry,
    public,
    index(name = idx_category_rank, btree(columns = [category, rank]))
)]
#[derive(Clone, Debug)]
pub struct LeaderboardEntry {
    #[primary_key]
    #[auto_inc]
    pub id: u64,
    pub category: LeaderboardCategory,
    pub rank: u32,
    pub player_id: Identity,
    pub player_username: String,
    pub value: u64,
    pub updated_at: Timestamp,
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/// Initialize or get PlayerStats for a player
pub fn get_or_init_player_stats(ctx: &ReducerContext, player_id: Identity) -> PlayerStats {
    let stats_table = ctx.db.player_stats();
    
    if let Some(stats) = stats_table.player_id().find(&player_id) {
        return stats.clone();
    }
    
    // Initialize new player stats
    let new_stats = PlayerStats {
        player_id,
        total_xp: 0,
        level: 1,
        xp_to_next_level: xp_for_level(1),
        fish_caught: 0,
        animals_killed: 0,
        cairns_discovered: 0,
        contracts_completed: 0,
        items_crafted: 0,
        trees_chopped: 0,
        stones_mined: 0,
        corals_mined: 0,
        plants_harvested: 0,
        deaths: 0,
        play_time_seconds: 0,
        longest_survival_seconds: 0,
        current_survival_start: Some(ctx.timestamp),
        total_shards_earned: 0,
        last_login_day: 0,
        login_streak_days: 0,
        active_title_id: None,
        updated_at: ctx.timestamp,
    };
    
    stats_table.insert(new_stats.clone());
    log::info!("Initialized PlayerStats for player {}", player_id);
    
    new_stats
}

/// Award XP to a player and check for level ups
pub fn award_xp(ctx: &ReducerContext, player_id: Identity, xp_amount: u64) -> Result<(), String> {
    let stats_table = ctx.db.player_stats();
    let mut stats = get_or_init_player_stats(ctx, player_id);
    
    let old_level = stats.level;
    stats.total_xp += xp_amount;
    stats.updated_at = ctx.timestamp;
    
    // Check for level up
    let mut new_level = stats.level;
    loop {
        let xp_needed_for_next = xp_for_level(new_level + 1);
        if stats.total_xp >= xp_needed_for_next {
            new_level += 1;
        } else {
            break;
        }
    }
    
    stats.level = new_level;
    stats.xp_to_next_level = if new_level > 0 {
        xp_for_level(new_level + 1)
    } else {
        xp_for_level(1)
    };
    
    // Update stats
    stats_table.player_id().update(stats.clone());
    
    // Send level up notification if leveled up
    if new_level > old_level {
        let level_up_notif = LevelUpNotification {
            id: 0,
            player_id,
            new_level,
            xp_awarded: xp_amount,
            unlocked_at: ctx.timestamp,
        };
        ctx.db.level_up_notification().insert(level_up_notif);
        log::info!("Player {} leveled up to level {}!", player_id, new_level);
        
        // Check for level-based achievements
        check_level_achievements(ctx, player_id, new_level)?;
    }
    
    // Check progress notifications
    check_progress_notifications(ctx, player_id, &stats)?;
    
    Ok(())
}

/// Track a stat increment and check for achievements
/// This is the overloaded version that increments a stat before checking
pub fn track_stat_and_check_achievements(
    ctx: &ReducerContext,
    player_id: Identity,
    stat_type: &str,
    amount: u64,
) -> Result<(), String> {
    let stats_table = ctx.db.player_stats();
    let mut stats = get_or_init_player_stats(ctx, player_id);
    
    // Increment the appropriate stat
    match stat_type {
        "fish_caught" => stats.fish_caught += amount as u32,
        "animals_killed" => stats.animals_killed += amount as u32,
        "cairns_discovered" => stats.cairns_discovered += amount as u32,
        "contracts_completed" => stats.contracts_completed += amount as u32,
        "items_crafted" => stats.items_crafted += amount as u32,
        "trees_chopped" => stats.trees_chopped += amount as u32,
        "stones_mined" => stats.stones_mined += amount as u32,
        "corals_mined" => stats.corals_mined += amount as u32,
        "plants_harvested" => stats.plants_harvested += amount as u32,
        "deaths" => stats.deaths += amount as u32,
        _ => {
            log::warn!("Unknown stat type: {}", stat_type);
            return Ok(());
        }
    }
    
    stats.updated_at = ctx.timestamp;
    stats_table.player_id().update(stats);
    
    // Now check achievements
    check_achievements(ctx, player_id)
}

/// Check and unlock achievements based on stats
pub fn check_achievements(ctx: &ReducerContext, player_id: Identity) -> Result<(), String> {
    let stats = get_or_init_player_stats(ctx, player_id);
    let achievement_defs = ctx.db.achievement_definition();
    let player_achievements = ctx.db.player_achievement();
    
    // Get already unlocked achievement IDs
    let unlocked_ids: Vec<String> = player_achievements
        .idx_player_achievements()
        .filter(&player_id)
        .map(|a| a.achievement_id.clone())
        .collect();
    
    // Check each achievement definition
    for achievement_def in achievement_defs.iter() {
        // Skip if already unlocked
        if unlocked_ids.contains(&achievement_def.id) {
            continue;
        }
        
        // Check if achievement conditions are met
        let should_unlock = match achievement_def.id.as_str() {
            // Cairn/Exploration achievements
            "first_cairn" => stats.cairns_discovered >= 1,
            "cairn_5" => stats.cairns_discovered >= 5,
            "cairn_hunter" => stats.cairns_discovered >= 10,
            "cairn_all" => stats.cairns_discovered >= 26,
            
            // Fishing achievements
            "fish_10" => stats.fish_caught >= 10,
            "fish_100" => stats.fish_caught >= 100,
            
            // Coral/Diving achievements
            "coral_10" => stats.corals_mined >= 10,
            "coral_100" => stats.corals_mined >= 100,
            
            // Plant/Foraging achievements
            "plants_50" => stats.plants_harvested >= 50,
            "plants_500" => stats.plants_harvested >= 500,
            
            // Combat achievements
            "animals_10" => stats.animals_killed >= 10,
            "animals_100" => stats.animals_killed >= 100,
            
            // Resource gathering achievements
            "trees_100" => stats.trees_chopped >= 100,
            "trees_1000" => stats.trees_chopped >= 1000,
            "stones_100" => stats.stones_mined >= 100,
            "stones_1000" => stats.stones_mined >= 1000,
            
            // Crafting achievements
            "crafted_50" => stats.items_crafted >= 50,
            "crafted_500" => stats.items_crafted >= 500,
            
            // Survival time achievements
            "survivor_1h" => stats.longest_survival_seconds >= 3600,
            "survivor_24h" => stats.longest_survival_seconds >= 86400,
            
            // Login streak achievements
            "login_7" => stats.login_streak_days >= 7,
            "login_30" => stats.login_streak_days >= 30,
            
            // Contract achievements
            "contracts_10" => stats.contracts_completed >= 10,
            "contracts_50" => stats.contracts_completed >= 50,
            "contracts_100" => stats.contracts_completed >= 100,
            
            // Level achievements  
            "level_10" => stats.level >= 10,
            "level_25" => stats.level >= 25,
            "level_50" => stats.level >= 50,
            "level_100" => stats.level >= 100,
            
            // Death achievements
            "first_death" => stats.deaths >= 1,
            "deaths_10" => stats.deaths >= 10,
            "deaths_50" => stats.deaths >= 50,
            
            // Shard achievements
            "shards_1000" => stats.total_shards_earned >= 1000,
            "shards_10000" => stats.total_shards_earned >= 10000,
            
            _ => false,
        };
        
        if should_unlock {
            unlock_achievement(ctx, player_id, &achievement_def)?;
        }
    }
    
    Ok(())
}

/// Unlock a specific achievement
fn unlock_achievement(
    ctx: &ReducerContext,
    player_id: Identity,
    achievement_def: &AchievementDefinition,
) -> Result<(), String> {
    // Check if already unlocked
    let already_unlocked = ctx.db.player_achievement()
        .idx_player_achievements()
        .filter(&player_id)
        .any(|a| a.achievement_id == achievement_def.id);
    
    if already_unlocked {
        return Ok(());
    }
    
    // Record achievement unlock
    ctx.db.player_achievement().insert(PlayerAchievement {
        id: 0,
        player_id,
        achievement_id: achievement_def.id.clone(),
        unlocked_at: ctx.timestamp,
    });
    
    // Award XP
    if achievement_def.xp_reward > 0 {
        award_xp(ctx, player_id, achievement_def.xp_reward)?;
    }
    
    // Send notification
    let notif = AchievementUnlockNotification {
        id: 0,
        player_id,
        achievement_id: achievement_def.id.clone(),
        achievement_name: achievement_def.name.clone(),
        xp_awarded: achievement_def.xp_reward,
        title_awarded: achievement_def.title_reward.clone(),
        unlocked_at: ctx.timestamp,
    };
    ctx.db.achievement_unlock_notification().insert(notif);
    
    // If title reward, make it available (but don't auto-equip)
    // Titles are managed separately via set_active_title reducer
    
    log::info!("Achievement unlocked: {} for player {}", achievement_def.name, player_id);
    
    Ok(())
}

/// Check level-based achievements
fn check_level_achievements(ctx: &ReducerContext, player_id: Identity, level: u32) -> Result<(), String> {
    check_achievements(ctx, player_id)
}

/// Check progress notifications (50%, 75%, 90% thresholds)
fn check_progress_notifications(
    ctx: &ReducerContext,
    player_id: Identity,
    stats: &PlayerStats,
) -> Result<(), String> {
    let current_xp = stats.total_xp;
    let xp_for_current_level = if stats.level > 1 {
        xp_for_level(stats.level)
    } else {
        0
    };
    let xp_for_next_level = stats.xp_to_next_level;
    let xp_in_current_level = current_xp.saturating_sub(xp_for_current_level);
    let xp_needed_for_next = xp_for_next_level.saturating_sub(xp_for_current_level);
    
    if xp_needed_for_next == 0 {
        return Ok(());
    }
    
    let progress = xp_in_current_level as f32 / xp_needed_for_next as f32;
    
    // Check thresholds (only send once per threshold)
    let last_notif = ctx.db.progress_notification()
        .idx_player_progress()
        .filter(&player_id)
        .max_by(|a, b| a.created_at.cmp(&b.created_at));
    
    let last_threshold = if let Some(notif) = last_notif {
        notif.progress_percent
    } else {
        0.0
    };
    
    let threshold_to_check = if progress >= PROGRESS_THRESHOLD_90 && last_threshold < PROGRESS_THRESHOLD_90 {
        Some((PROGRESS_THRESHOLD_90, "90% to next level!"))
    } else if progress >= PROGRESS_THRESHOLD_75 && last_threshold < PROGRESS_THRESHOLD_75 {
        Some((PROGRESS_THRESHOLD_75, "75% to next level!"))
    } else if progress >= PROGRESS_THRESHOLD_50 && last_threshold < PROGRESS_THRESHOLD_50 {
        Some((PROGRESS_THRESHOLD_50, "50% to next level!"))
    } else {
        None
    };
    
    if let Some((threshold, message)) = threshold_to_check {
        let notif = ProgressNotification {
            id: 0,
            player_id,
            message: message.to_string(),
            progress_type: ProgressType::Level,
            current_value: xp_in_current_level,
            target_value: xp_needed_for_next,
            progress_percent: threshold,
            created_at: ctx.timestamp,
        };
        ctx.db.progress_notification().insert(notif);
    }
    
    Ok(())
}

/// Calculate percentile for a value in a distribution
pub fn calculate_percentile(value: u64, all_values: &[u64]) -> f32 {
    if all_values.is_empty() {
        return 0.0;
    }
    
    let mut sorted = all_values.to_vec();
    sorted.sort();
    
    let count_below = sorted.iter().filter(|&&v| v < value).count();
    let count_equal = sorted.iter().filter(|&&v| v == value).count();
    
    // Percentile = (count_below + 0.5 * count_equal) / total
    let percentile = (count_below as f32 + 0.5 * count_equal as f32) / sorted.len() as f32;
    percentile * 100.0 // Return as percentage (0-100)
}

/// Initialize achievement definitions (called in init_module)
pub fn seed_achievements(ctx: &ReducerContext) -> Result<(), String> {
    let achievement_table = ctx.db.achievement_definition();
    
    // Check if already seeded
    if achievement_table.iter().count() > 0 {
        log::debug!("Achievement definitions already seeded");
        return Ok(());
    }
    
    let achievements = vec![
        AchievementDefinition {
            id: "first_cairn".to_string(),
            name: "Curious Explorer".to_string(),
            description: "Discover your first cairn".to_string(),
            icon: "ðŸ—¿".to_string(),
            xp_reward: 50,
            title_reward: None,
            category: AchievementCategory::Exploration,
        },
        AchievementDefinition {
            id: "cairn_hunter".to_string(),
            name: "Lore Keeper".to_string(),
            description: "Discover 10 cairns".to_string(),
            icon: "ðŸ“š".to_string(),
            xp_reward: 200,
            title_reward: Some("Lore Keeper".to_string()),
            category: AchievementCategory::Exploration,
        },
        AchievementDefinition {
            id: "fish_10".to_string(),
            name: "Novice Angler".to_string(),
            description: "Catch 10 fish".to_string(),
            icon: "ðŸŽ£".to_string(),
            xp_reward: 50,
            title_reward: None,
            category: AchievementCategory::Collection,
        },
        AchievementDefinition {
            id: "fish_100".to_string(),
            name: "Master Angler".to_string(),
            description: "Catch 100 fish".to_string(),
            icon: "ðŸŸ".to_string(),
            xp_reward: 300,
            title_reward: Some("Master Angler".to_string()),
            category: AchievementCategory::Collection,
        },
        AchievementDefinition {
            id: "survivor_1h".to_string(),
            name: "Survivor".to_string(),
            description: "Survive for 1 hour".to_string(),
            icon: "â±ï¸".to_string(),
            xp_reward: 100,
            title_reward: None,
            category: AchievementCategory::Survival,
        },
        AchievementDefinition {
            id: "survivor_24h".to_string(),
            name: "Veteran".to_string(),
            description: "Survive for 24 hours".to_string(),
            icon: "ðŸ†".to_string(),
            xp_reward: 500,
            title_reward: Some("Veteran".to_string()),
            category: AchievementCategory::Survival,
        },
        AchievementDefinition {
            id: "contracts_10".to_string(),
            name: "Contractor".to_string(),
            description: "Complete 10 ALK contracts".to_string(),
            icon: "ðŸ“‹".to_string(),
            xp_reward: 150,
            title_reward: None,
            category: AchievementCategory::Social,
        },
        AchievementDefinition {
            id: "contracts_50".to_string(),
            name: "ALK Elite".to_string(),
            description: "Complete 50 ALK contracts".to_string(),
            icon: "â­".to_string(),
            xp_reward: 400,
            title_reward: Some("ALK Elite".to_string()),
            category: AchievementCategory::Social,
        },
        AchievementDefinition {
            id: "first_death".to_string(),
            name: "Learning Experience".to_string(),
            description: "Die for the first time".to_string(),
            icon: "ðŸ’€".to_string(),
            xp_reward: 10,
            title_reward: None,
            category: AchievementCategory::Survival,
        },
        AchievementDefinition {
            id: "level_10".to_string(),
            name: "Rising Star".to_string(),
            description: "Reach level 10".to_string(),
            icon: "â­".to_string(),
            xp_reward: 200,
            title_reward: None,
            category: AchievementCategory::Survival,
        },
        AchievementDefinition {
            id: "level_25".to_string(),
            name: "Established".to_string(),
            description: "Reach level 25".to_string(),
            icon: "ðŸŒŸ".to_string(),
            xp_reward: 500,
            title_reward: Some("Established".to_string()),
            category: AchievementCategory::Survival,
        },
        // === LORE-THEMED ACHIEVEMENTS ===
        // Based on the game's world: Bering Sea, ALK Compound, Aleut culture, volcanic island
        
        // Cairn Lore Discoveries (themed around the narrative)
        AchievementDefinition {
            id: "cairn_all".to_string(),
            name: "Truth Seeker".to_string(),
            description: "Discover all 26 cairns and uncover the island's secrets".to_string(),
            icon: "ðŸ“–".to_string(),
            xp_reward: 1000,
            title_reward: Some("Truth Seeker".to_string()),
            category: AchievementCategory::Exploration,
        },
        AchievementDefinition {
            id: "cairn_5".to_string(),
            name: "Whispers of Stone".to_string(),
            description: "Discover 5 cairns".to_string(),
            icon: "ðŸ—¿".to_string(),
            xp_reward: 100,
            title_reward: None,
            category: AchievementCategory::Exploration,
        },
        
        // Underwater/Diving themed (Bering Sea lore)
        AchievementDefinition {
            id: "coral_10".to_string(),
            name: "Shallow Diver".to_string(),
            description: "Mine coral 10 times".to_string(),
            icon: "ðŸª¸".to_string(),
            xp_reward: 50,
            title_reward: None,
            category: AchievementCategory::Collection,
        },
        AchievementDefinition {
            id: "coral_100".to_string(),
            name: "Bering's Child".to_string(),
            description: "Mine coral 100 times - master the frigid waters".to_string(),
            icon: "ðŸŒŠ".to_string(),
            xp_reward: 300,
            title_reward: Some("Bering's Child".to_string()),
            category: AchievementCategory::Collection,
        },
        
        // Gathering/Foraging themed
        AchievementDefinition {
            id: "plants_50".to_string(),
            name: "Forager".to_string(),
            description: "Harvest 50 wild plants".to_string(),
            icon: "ðŸŒ¿".to_string(),
            xp_reward: 75,
            title_reward: None,
            category: AchievementCategory::Collection,
        },
        AchievementDefinition {
            id: "plants_500".to_string(),
            name: "Islander".to_string(),
            description: "Harvest 500 plants - live off the land like the Aleuts".to_string(),
            icon: "ðŸï¸".to_string(),
            xp_reward: 400,
            title_reward: Some("Islander".to_string()),
            category: AchievementCategory::Collection,
        },
        
        // Combat themed
        AchievementDefinition {
            id: "animals_10".to_string(),
            name: "Hunter".to_string(),
            description: "Kill 10 wild animals".to_string(),
            icon: "ðŸ¹".to_string(),
            xp_reward: 75,
            title_reward: None,
            category: AchievementCategory::Combat,
        },
        AchievementDefinition {
            id: "animals_100".to_string(),
            name: "Apex Predator".to_string(),
            description: "Kill 100 wild animals - dominate the food chain".to_string(),
            icon: "ðŸº".to_string(),
            xp_reward: 400,
            title_reward: Some("Apex Predator".to_string()),
            category: AchievementCategory::Combat,
        },
        
        // Resource gathering themed (volcanic island)
        AchievementDefinition {
            id: "trees_100".to_string(),
            name: "Woodcutter".to_string(),
            description: "Chop down 100 trees".to_string(),
            icon: "ðŸª“".to_string(),
            xp_reward: 100,
            title_reward: None,
            category: AchievementCategory::Collection,
        },
        AchievementDefinition {
            id: "trees_1000".to_string(),
            name: "Deforester".to_string(),
            description: "Chop down 1000 trees - reshape the landscape".to_string(),
            icon: "ðŸŒ²".to_string(),
            xp_reward: 500,
            title_reward: Some("Deforester".to_string()),
            category: AchievementCategory::Collection,
        },
        AchievementDefinition {
            id: "stones_100".to_string(),
            name: "Quarrier".to_string(),
            description: "Mine 100 stone deposits".to_string(),
            icon: "â›ï¸".to_string(),
            xp_reward: 100,
            title_reward: None,
            category: AchievementCategory::Collection,
        },
        AchievementDefinition {
            id: "stones_1000".to_string(),
            name: "Volcanic Born".to_string(),
            description: "Mine 1000 stones - harness the island's ancient fire".to_string(),
            icon: "ðŸŒ‹".to_string(),
            xp_reward: 500,
            title_reward: Some("Volcanic Born".to_string()),
            category: AchievementCategory::Collection,
        },
        
        // Crafting themed
        AchievementDefinition {
            id: "crafted_50".to_string(),
            name: "Tinkerer".to_string(),
            description: "Craft 50 items".to_string(),
            icon: "ðŸ”§".to_string(),
            xp_reward: 75,
            title_reward: None,
            category: AchievementCategory::Crafting,
        },
        AchievementDefinition {
            id: "crafted_500".to_string(),
            name: "Master Craftsman".to_string(),
            description: "Craft 500 items - innovation through necessity".to_string(),
            icon: "âš’ï¸".to_string(),
            xp_reward: 400,
            title_reward: Some("Master Craftsman".to_string()),
            category: AchievementCategory::Crafting,
        },
        
        // Survival streaks (ALK compound theme - "the loop")
        AchievementDefinition {
            id: "login_7".to_string(),
            name: "Routine".to_string(),
            description: "Log in for 7 consecutive days".to_string(),
            icon: "ðŸ“…".to_string(),
            xp_reward: 200,
            title_reward: None,
            category: AchievementCategory::Social,
        },
        AchievementDefinition {
            id: "login_30".to_string(),
            name: "Institutionalized".to_string(),
            description: "Log in for 30 consecutive days - the compound is your home now".to_string(),
            icon: "ðŸ›ï¸".to_string(),
            xp_reward: 750,
            title_reward: Some("Institutionalized".to_string()),
            category: AchievementCategory::Social,
        },
        
        // Level achievements
        AchievementDefinition {
            id: "level_50".to_string(),
            name: "Seasoned".to_string(),
            description: "Reach level 50".to_string(),
            icon: "ðŸ’Ž".to_string(),
            xp_reward: 1000,
            title_reward: Some("Seasoned".to_string()),
            category: AchievementCategory::Survival,
        },
        AchievementDefinition {
            id: "level_100".to_string(),
            name: "Legend of the Compound".to_string(),
            description: "Reach level 100 - transcend the system".to_string(),
            icon: "ðŸ‘‘".to_string(),
            xp_reward: 2500,
            title_reward: Some("Legend".to_string()),
            category: AchievementCategory::Survival,
        },
        
        // Death-related (The Freeze lore)
        AchievementDefinition {
            id: "deaths_10".to_string(),
            name: "Resilient".to_string(),
            description: "Die 10 times and keep coming back".to_string(),
            icon: "ðŸ”„".to_string(),
            xp_reward: 100,
            title_reward: None,
            category: AchievementCategory::Survival,
        },
        AchievementDefinition {
            id: "deaths_50".to_string(),
            name: "Ghost".to_string(),
            description: "Die 50 times - death is just a reset in the compound".to_string(),
            icon: "ðŸ‘»".to_string(),
            xp_reward: 250,
            title_reward: Some("Ghost".to_string()),
            category: AchievementCategory::Survival,
        },
        
        // ALK Contracts themed (Directorate lore)
        AchievementDefinition {
            id: "contracts_100".to_string(),
            name: "Directorate Asset".to_string(),
            description: "Complete 100 ALK contracts - indispensable to the system".to_string(),
            icon: "ðŸŽ–ï¸".to_string(),
            xp_reward: 800,
            title_reward: Some("Directorate Asset".to_string()),
            category: AchievementCategory::Social,
        },
        
        // Shards themed (the mysterious currency)
        AchievementDefinition {
            id: "shards_1000".to_string(),
            name: "Shard Collector".to_string(),
            description: "Earn 1000 total shards".to_string(),
            icon: "ðŸ’ ".to_string(),
            xp_reward: 150,
            title_reward: None,
            category: AchievementCategory::Collection,
        },
        AchievementDefinition {
            id: "shards_10000".to_string(),
            name: "Shard Baron".to_string(),
            description: "Earn 10000 total shards - what are they really for?".to_string(),
            icon: "ðŸ”®".to_string(),
            xp_reward: 600,
            title_reward: Some("Shard Baron".to_string()),
            category: AchievementCategory::Collection,
        },
    ];
    
    for achievement in achievements {
        achievement_table.insert(achievement);
    }
    
    log::info!("Seeded {} achievement definitions", achievement_table.iter().count());
    Ok(())
}

/// Initialize daily login rewards (called in init_module)
pub fn seed_daily_login_rewards(ctx: &ReducerContext) -> Result<(), String> {
    let reward_table = ctx.db.daily_login_reward();
    
    // Check if already seeded
    if reward_table.iter().count() > 0 {
        log::debug!("Daily login rewards already seeded");
        return Ok(());
    }
    
    let rewards = vec![
        DailyLoginReward { day: 1, shard_reward: 10, bonus_xp: 25 },
        DailyLoginReward { day: 2, shard_reward: 15, bonus_xp: 50 },
        DailyLoginReward { day: 3, shard_reward: 25, bonus_xp: 75 },
        DailyLoginReward { day: 4, shard_reward: 35, bonus_xp: 100 },
        DailyLoginReward { day: 5, shard_reward: 50, bonus_xp: 150 },
        DailyLoginReward { day: 6, shard_reward: 75, bonus_xp: 200 },
        DailyLoginReward { day: 7, shard_reward: 150, bonus_xp: 500 },
    ];
    
    for reward in rewards {
        reward_table.insert(reward);
    }
    
    log::info!("Seeded daily login rewards");
    Ok(())
}

// ============================================================================
// REDUCERS
// ============================================================================

/// Set active title for a player
#[spacetimedb::reducer]
pub fn set_active_title(ctx: &ReducerContext, title_id: Option<String>) -> Result<(), String> {
    let player_id = ctx.sender;
    let stats_table = ctx.db.player_stats();
    
    // Verify player has unlocked this title (check achievements)
    if let Some(ref title) = title_id {
        let has_title = ctx.db.player_achievement()
            .idx_player_achievements()
            .filter(&player_id)
            .any(|a| {
                if let Some(achievement) = ctx.db.achievement_definition().id().find(&a.achievement_id) {
                    achievement.title_reward.as_ref() == Some(title)
                } else {
                    false
                }
            });
        
        if !has_title {
            return Err(format!("You haven't unlocked the title '{}'", title));
        }
    }
    
    let mut stats = get_or_init_player_stats(ctx, player_id);
    stats.active_title_id = title_id.clone();
    stats.updated_at = ctx.timestamp;
    stats_table.player_id().update(stats);
    
    log::info!("Player {} set active title to {:?}", player_id, title_id);
    Ok(())
}

/// Get leaderboard for a category
#[spacetimedb::reducer]
pub fn get_leaderboard(ctx: &ReducerContext, category: LeaderboardCategory, limit: u32) -> Result<(), String> {
    let stats_table = ctx.db.player_stats();
    let players_table = ctx.db.player();
    let leaderboard_table = ctx.db.leaderboard_entry();
    
    // Clear old entries for this category
    let old_entries: Vec<_> = leaderboard_table
        .iter()
        .filter(|e| e.category == category)
        .collect();
    for entry in old_entries {
        leaderboard_table.id().delete(entry.id);
    }
    
    // Get all stats and sort by category
    let mut entries: Vec<(Identity, u64, String)> = Vec::new();
    
    for stats in stats_table.iter() {
        if let Some(player) = players_table.identity().find(&stats.player_id) {
            let value = match category {
                LeaderboardCategory::ShardsEarned => stats.total_shards_earned as u64,
                LeaderboardCategory::LongestSurvival => stats.longest_survival_seconds,
                LeaderboardCategory::ContractsCompleted => stats.contracts_completed as u64,
                LeaderboardCategory::FishCaught => stats.fish_caught as u64,
                LeaderboardCategory::CairnsDiscovered => stats.cairns_discovered as u64,
                LeaderboardCategory::Level => stats.level as u64,
            };
            
            entries.push((stats.player_id, value, player.username.clone()));
        }
    }
    
    // Sort descending
    entries.sort_by(|a, b| b.1.cmp(&a.1));
    
    // Create leaderboard entries
    for (rank, (player_id, value, username)) in entries.iter().enumerate().take(limit as usize) {
        let entry = LeaderboardEntry {
            id: 0,
            category: category.clone(),
            rank: (rank + 1) as u32,
            player_id: *player_id,
            player_username: username.clone(),
            value: *value,
            updated_at: ctx.timestamp,
        };
        leaderboard_table.insert(entry);
    }
    
    log::info!("Generated leaderboard for {:?} with {} entries", category, entries.len().min(limit as usize));
    Ok(())
}

