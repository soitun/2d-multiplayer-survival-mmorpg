/******************************************************************************
 *                                                                            *
 * AI Brewing System - Generative Recipe Creation                             *
 *                                                                            *
 * Handles AI-generated brew recipes, caching, and dynamic ItemDefinition     *
 * creation. Recipes are generated by the client via Gemini API and cached    *
 * server-side for consistency.                                               *
 *                                                                            *
 ******************************************************************************/

use spacetimedb::{ReducerContext, Table, Timestamp, SpacetimeType, log};
use serde::{Deserialize, Serialize};
use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};

use crate::items::{
    ItemDefinition, ItemCategory, 
    item_definition as ItemDefinitionTableTrait,
    inventory_item as InventoryItemTableTrait,
    InventoryItem,
};
use crate::models::ItemLocation;
use crate::active_effects::EffectType;

// ============================================================================
// TABLES
// ============================================================================

/// Cache for AI-generated brew recipes.
/// Once a recipe is generated for a specific ingredient combination,
/// it's stored here so the same ingredients always produce the same result.
#[spacetimedb::table(name = brew_recipe_cache, public)]
#[derive(Clone, Debug)]
pub struct BrewRecipeCache {
    #[primary_key]
    pub recipe_hash: u64,           // Hash of sorted ingredient names
    pub ingredient_names_json: String, // JSON array of ingredient names (sorted)
    pub output_item_def_id: u64,    // Links to dynamically created ItemDefinition
    pub brew_time_secs: u32,        // Time to brew in seconds
    pub category: String,           // Brew category (healing_broth, poison, etc.)
    pub effect_type: Option<String>, // Maps to EffectType for special brews
    pub icon_base64: Option<String>, // Base64 PNG icon data (optional, can be large)
    pub created_at: Timestamp,
}

// ============================================================================
// BREW CATEGORIES & EFFECT MAPPINGS
// ============================================================================

/// Valid brew categories that AI can generate
/// Categories with special effects (1-hour duration, cleared on death):
/// - alcoholic: Intoxicated (drunk effect)
/// - poison: Poisoned (DOT)
/// - performance_enhancer: SpeedBoost (25% faster)
/// - psychoactive: NightVision
/// - warming_broth: WarmthBoost (50% reduced warmth decay)
/// - cold_resistant_brew: ColdResistance (50% reduced cold damage)
/// - fire_resistant_brew: FireResistance (50% reduced fire damage)
/// - antidote_brew: PoisonResistance (75% reduced poison damage, acts as antivenom)
/// - endurance_broth: StaminaBoost (50% reduced hunger/thirst drain)
/// - healing_elixir: PassiveHealthRegen (slow 1-hour health regen)
/// - harvester_brew: HarvestBoost (50% bonus mining/chopping yield)
/// - weapon_coating: PoisonCoating (attacks inflict poison)i noticed the 60s "recentyl consumed a brew" disapepars immediately its supposed to last 60 seconds i see it just momentaryil on @client/src/components/StatusEffectsPanel.tsx but then itj ust disappears make sure this works
/// Categories without special effects (use consumable stats only):
/// - healing_broth, medicinal_tea: Use consumable_health_gain stat
/// - nutritional_drink, maritime_specialty, technological, utility_brew: Various stat effects
pub const VALID_BREW_CATEGORIES: &[&str] = &[
    // === CATEGORIES WITH NO SPECIAL EFFECTS (stats only) ===
    "healing_broth",       // Heals via consumable_health_gain stat
    "medicinal_tea",       // Heals via consumable_health_gain stat
    "nutritional_drink",   // Hunger/thirst via consumable stats
    "maritime_specialty",  // Various stat boosts
    "technological",       // Tech/utility items
    "utility_brew",        // Misc utility effects via stats
    
    // === CATEGORIES WITH SPECIAL EFFECTS (1-hour buffs, cleared on death) ===
    "alcoholic",           // Intoxicated - drunk, 15% speed penalty
    "poison",              // Poisoned - damage over time
    "performance_enhancer", // SpeedBoost - 25% faster movement
    "psychoactive",        // NightVision - enhanced night vision
    "warming_broth",       // WarmthBoost - 50% reduced warmth decay
    "cold_resistant_brew", // ColdResistance - 50% reduced cold damage
    "fire_resistant_brew", // FireResistance - 50% reduced fire damage
    "antidote_brew",       // PoisonResistance - 75% poison resist (antivenom)
    "endurance_broth",     // StaminaBoost - 50% reduced hunger/thirst drain
    "healing_elixir",      // PassiveHealthRegen - slow 1-hour regen
    "harvester_brew",      // HarvestBoost - 50% bonus mining/chopping yield
    "weapon_coating",      // PoisonCoating - attacks inflict poison
];

/// Maps brew categories to server-side EffectType variants
/// Returns None for categories that only use stats (health/hunger/thirst)
/// NOTE: medicinal_tea and healing_broth should NOT map to HealthRegen - 
/// their healing is handled by consumable_health_gain stat on the item definition.
/// Creating a stub HealthRegen effect would conflict with the real healing effect.
/// 
/// === BROTH SYSTEM CATEGORIES (1-hour buffs, cleared on death) ===
/// - warming_broth: WarmthBoost - 50% reduced warmth decay
/// - cold_resistant_brew: ColdResistance - 50% reduced cold damage
/// - fire_resistant_brew: FireResistance - 50% reduced fire/burn damage
/// - antidote_brew: PoisonResistance - 75% reduced poison/venom damage (acts as antivenom)
/// - endurance_broth: StaminaBoost - 50% reduced hunger/thirst drain
/// - healing_elixir: PassiveHealthRegen - Slow 1-hour health regeneration
/// - harvester_brew: HarvestBoost - 50% bonus yield from mining/chopping
/// - weapon_coating: PoisonCoating - Attacks inflict poison on targets
pub fn map_category_to_effect(category: &str) -> Option<EffectType> {
    match category {
        // medicinal_tea: healing handled by item's consumable_health_gain stat, no special effect needed
        // healing_broth: healing handled by item's consumable_health_gain stat, no special effect needed
        "poison" => Some(EffectType::PoisonCoating),     // Weapon coating - attacks inflict poison
        "alcoholic" => Some(EffectType::Intoxicated),     // Drunk effect - 15% speed penalty, blurred vision
        "performance_enhancer" => Some(EffectType::SpeedBoost), // 25% faster movement
        "psychoactive" => Some(EffectType::NightVision),  // Enhanced vision at night
        
        // === BROTH BUFFS (1 hour duration, cleared on death) ===
        "warming_broth" => Some(EffectType::WarmthBoost),      // 50% reduced warmth decay from cold
        "cold_resistant_brew" => Some(EffectType::ColdResistance), // 50% reduced cold damage
        "fire_resistant_brew" => Some(EffectType::FireResistance), // 50% reduced fire/burn damage
        "antidote_brew" => Some(EffectType::PoisonResistance), // 75% reduced poison/venom damage (antivenom)
        "endurance_broth" => Some(EffectType::StaminaBoost),   // 50% reduced hunger/thirst drain
        "healing_elixir" => Some(EffectType::PassiveHealthRegen), // Slow passive health regen over 1 hour
        "harvester_brew" => Some(EffectType::HarvestBoost),    // 50% bonus yield from mining/chopping
        "weapon_coating" => Some(EffectType::PoisonCoating),   // Attacks inflict poison on targets
        
        // These categories use stats only (no special effect):
        // medicinal_tea, healing_broth, nutritional_drink, maritime_specialty, technological, utility_brew
        _ => None,
    }
}

/// Maps effect type string from AI to EffectType enum
pub fn parse_effect_type(effect_str: &str) -> Option<EffectType> {
    match effect_str {
        // Existing effects
        "HealthRegen" => Some(EffectType::HealthRegen),
        "FoodPoisoning" => Some(EffectType::FoodPoisoning),
        "Venom" => Some(EffectType::Venom),
        "Burn" => Some(EffectType::Burn),
        "Bleed" => Some(EffectType::Bleed),
        // Brewing system effects - 1 hour buffs that don't persist through death
        "Intoxicated" => Some(EffectType::Intoxicated),      // Drunk - movement wobble, 15% speed penalty
        "Poisoned" => Some(EffectType::Poisoned),            // DOT from poison brews
        "SpeedBoost" => Some(EffectType::SpeedBoost),        // 25% faster movement
        "StaminaBoost" => Some(EffectType::StaminaBoost),    // 50% reduced hunger/thirst drain
        "NightVision" => Some(EffectType::NightVision),      // Enhanced vision at night
        "WarmthBoost" => Some(EffectType::WarmthBoost),      // 50% reduced warmth decay
        "ColdResistance" => Some(EffectType::ColdResistance),// 50% reduced cold damage
        "PoisonResistance" => Some(EffectType::PoisonResistance), // 75% reduced poison/venom damage (acts as antivenom)
        "FireResistance" => Some(EffectType::FireResistance),// 50% reduced fire/burn damage
        // Additional broth effects
        "PoisonCoating" => Some(EffectType::PoisonCoating),  // Attacks inflict poison on targets
        "PassiveHealthRegen" => Some(EffectType::PassiveHealthRegen), // Slow 1-hour health regen
        "HarvestBoost" => Some(EffectType::HarvestBoost),    // 50% bonus yield from mining/chopping
        _ => None,
    }
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/// Computes a consistent hash for a set of ingredient names.
/// Ingredients are sorted alphabetically before hashing to ensure
/// the same ingredients in any order produce the same hash.
pub fn compute_recipe_hash(ingredients: &[String]) -> u64 {
    let mut sorted_ingredients = ingredients.to_vec();
    sorted_ingredients.sort();
    
    let mut hasher = DefaultHasher::new();
    for ingredient in &sorted_ingredients {
        ingredient.hash(&mut hasher);
    }
    hasher.finish()
}

/// Data structure for the recipe JSON received from the AI
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct AiBrewRecipeData {
    pub name: String,
    pub description: String,
    pub health: f32,
    pub hunger: f32,
    pub thirst: f32,
    pub brew_time_secs: u32,
    pub category: String,
    pub effect_type: Option<String>,
    pub icon_subject: String, // Description for icon generation
    pub ingredients: Vec<String>, // The ingredients used (for verification)
}

/// Validates that the AI-generated recipe has valid values
fn validate_recipe_data(recipe: &AiBrewRecipeData) -> Result<(), String> {
    // Name validation
    if recipe.name.is_empty() {
        return Err("Recipe name cannot be empty".to_string());
    }
    if recipe.name.len() > 100 {
        return Err("Recipe name too long (max 100 chars)".to_string());
    }
    
    // Description validation
    if recipe.description.len() > 500 {
        return Err("Recipe description too long (max 500 chars)".to_string());
    }
    
    // Stat validation (allow negative for poisons, but cap extremes)
    // CRITICAL: Poison category brews MUST have zero stats (weapon coating only)
    if recipe.category == "poison" {
        if recipe.health != 0.0 {
            return Err("Poison category brews must have health: 0 (weapon coating only, no consumable stats)".to_string());
        }
        if recipe.hunger != 0.0 {
            return Err("Poison category brews must have hunger: 0 (weapon coating only, no consumable stats)".to_string());
        }
        if recipe.thirst != 0.0 {
            return Err("Poison category brews must have thirst: 0 (weapon coating only, no consumable stats)".to_string());
        }
        // Verify effect_type is PoisonCoating
        if let Some(ref effect_type) = recipe.effect_type {
            if effect_type != "PoisonCoating" {
                return Err(format!("Poison category brews must use effect_type 'PoisonCoating', got '{}'", effect_type));
            }
        } else {
            return Err("Poison category brews must have effect_type 'PoisonCoating'".to_string());
        }
    } else {
        // Normal stat validation for non-poison brews
        if recipe.health < -500.0 || recipe.health > 500.0 {
            return Err("Health value out of range (-500 to 500)".to_string());
        }
        if recipe.hunger < -200.0 || recipe.hunger > 200.0 {
            return Err("Hunger value out of range (-200 to 200)".to_string());
        }
        if recipe.thirst < -200.0 || recipe.thirst > 200.0 {
            return Err("Thirst value out of range (-200 to 200)".to_string());
        }
    }
    
    // Brew time validation (fast-paced PvP game - quick brewing)
    if recipe.brew_time_secs < 15 || recipe.brew_time_secs > 30 {
        return Err("Brew time out of range (15-30 seconds)".to_string());
    }
    
    // Category validation
    if !VALID_BREW_CATEGORIES.contains(&recipe.category.as_str()) {
        return Err(format!("Invalid category: {}", recipe.category));
    }
    
    // Ingredients validation
    if recipe.ingredients.len() != 3 {
        return Err("Exactly 3 ingredients required".to_string());
    }
    
    Ok(())
}

// ============================================================================
// REDUCERS
// ============================================================================

/// Check if a recipe exists in the cache for the given ingredient hash.
/// Returns the cached recipe data if found.
/// 
/// Called by the client before generating a new AI recipe to avoid
/// regenerating recipes for known ingredient combinations.
#[spacetimedb::reducer]
pub fn check_brew_cache(ctx: &ReducerContext, recipe_hash: u64) -> Result<(), String> {
    let cache = ctx.db.brew_recipe_cache();
    
    if let Some(cached) = cache.recipe_hash().find(recipe_hash) {
        log::info!(
            "[AI_BREWING] Cache HIT for hash {}: output_def_id={}",
            recipe_hash, cached.output_item_def_id
        );
        // Recipe exists - client can use the cached output_item_def_id
        Ok(())
    } else {
        log::info!("[AI_BREWING] Cache MISS for hash {}", recipe_hash);
        // Recipe doesn't exist - client should generate via AI
        Err("Recipe not cached".to_string())
    }
}

/// Creates a new AI-generated brew recipe in the database.
/// Called by the client after receiving recipe data from the Gemini API.
/// 
/// This reducer:
/// 1. Validates the recipe data
/// 2. Creates a new ItemDefinition for the brew output
/// 3. Caches the recipe for future consistency
/// 
/// Arguments:
/// - recipe_json: JSON string of AiBrewRecipeData
/// - icon_base64: Optional base64-encoded PNG icon
#[spacetimedb::reducer]
pub fn create_generated_brew(
    ctx: &ReducerContext,
    recipe_json: String,
    icon_base64: Option<String>,
) -> Result<(), String> {
    // Parse the recipe JSON
    let recipe_data: AiBrewRecipeData = serde_json::from_str(&recipe_json)
        .map_err(|e| format!("Failed to parse recipe JSON: {}", e))?;
    
    log::info!(
        "[AI_BREWING] Creating generated brew: '{}' from ingredients: {:?}",
        recipe_data.name, recipe_data.ingredients
    );
    
    // Validate the recipe data
    validate_recipe_data(&recipe_data)?;
    
    // Compute the recipe hash
    let recipe_hash = compute_recipe_hash(&recipe_data.ingredients);
    
    // Check if already cached (race condition protection)
    let cache = ctx.db.brew_recipe_cache();
    if cache.recipe_hash().find(recipe_hash).is_some() {
        log::warn!(
            "[AI_BREWING] Recipe hash {} already exists (race condition), skipping creation",
            recipe_hash
        );
        return Ok(());
    }
    
    // Check if an ItemDefinition with this name already exists
    let item_defs = ctx.db.item_definition();
    let existing_def = item_defs.iter().find(|def| def.name == recipe_data.name);
    
    let output_def_id = if let Some(existing) = existing_def {
        log::info!(
            "[AI_BREWING] ItemDefinition '{}' already exists with id={}",
            recipe_data.name, existing.id
        );
        existing.id
    } else {
        // Create new ItemDefinition for the brew output
        // Use AI-generated base64 icon if available, otherwise empty string (client shows ? icon)
        let icon_asset = icon_base64
            .as_ref()
            .filter(|s| !s.is_empty())
            .cloned()
            .unwrap_or_default();
        
        let new_item_def = ItemDefinition {
            id: 0, // Auto-inc
            name: recipe_data.name.clone(),
            description: recipe_data.description.clone(),
            category: ItemCategory::Consumable,
            icon_asset_name: icon_asset,
            is_stackable: true,
            stack_size: 10,
            is_equippable: false,
            equipment_slot_type: None,
            fuel_burn_duration_secs: None,
            
            // No harvesting/damage stats for consumables
            primary_target_damage_min: None,
            primary_target_damage_max: None,
            primary_target_yield_min: None,
            primary_target_yield_max: None,
            primary_target_type: None,
            primary_yield_resource_name: None,
            pvp_damage_min: None,
            pvp_damage_max: None,
            bleed_damage_per_tick: None,
            bleed_duration_seconds: None,
            bleed_tick_interval_seconds: None,
            
            // Not craftable through normal crafting menu
            crafting_cost: None,
            alternative_crafting_costs: None,
            flexible_ingredients: None,
            crafting_output_quantity: None,
            crafting_time_secs: None,
            
            // Consumable effects from AI generation
            consumable_health_gain: Some(recipe_data.health),
            consumable_hunger_satiated: Some(recipe_data.hunger),
            consumable_thirst_quenched: Some(recipe_data.thirst),
            consumable_duration_secs: None, // Instant consumption
            
            // Cooking and other item properties (not applicable for brewed items)
            cook_time_secs: None,
            cooked_item_def_name: None,
            extraction_output_name: None,
            extraction_output_min: None,
            extraction_output_max: None,
            extraction_action_label: None,
            damage_resistance: None,
            warmth_bonus: None,
            respawn_time_seconds: None,
            attack_interval_secs: None,
            
            // Armor system fields (not applicable)
            damage_type: None,
            armor_resistances: None,
            movement_speed_modifier: None,
            stamina_regen_modifier: None,
            reflects_melee_damage: None,
            fire_damage_multiplier: None,
            detection_radius_bonus: None,
            low_health_damage_bonus: None,
            
            // Armor special properties (not applicable)
            grants_burn_immunity: false,
            grants_cold_immunity: false,
            grants_wetness_immunity: false,
            grants_knockback_immunity: false,
            grants_bleed_immunity: false,
            grants_night_vision: false,
            noise_on_sprint: false,
            silences_movement: false,
            intimidates_animals: false,
            
            // Ammunition type (not applicable for consumables)
            ammo_type: None,
            
            // Station requirement (not applicable for AI-generated brews)
            requires_station: None,
            
            // Attack arc (not applicable for consumables)
            attack_arc_degrees: None,
            
            // Water speed bonus (not applicable for consumables)
            water_speed_bonus: None,
            
            // Food preservation (brewed items are fresh, not preserved)
            is_preserved: false,
            spoils_after_hours: None, // AI brews use default food spoilage calculation
            
            // Bone totem passive bonuses (not applicable for consumables)
            harvest_bonus: None,
            ally_damage_bonus: None,
            poison_damage_on_hit: None,
            max_health_bonus: None,
            bleed_chance_on_melee: None,
            reduces_animal_detection: None,
            melee_damage_bonus: None,
        };
        
        let inserted = item_defs.insert(new_item_def);
        log::info!(
            "[AI_BREWING] Created new ItemDefinition '{}' with id={}",
            recipe_data.name, inserted.id
        );
        inserted.id
    };
    
    // Serialize ingredients to JSON for storage
    let ingredients_json = serde_json::to_string(&recipe_data.ingredients)
        .map_err(|e| format!("Failed to serialize ingredients: {}", e))?;
    
    // Create cache entry
    let cache_entry = BrewRecipeCache {
        recipe_hash,
        ingredient_names_json: ingredients_json,
        output_item_def_id: output_def_id,
        brew_time_secs: recipe_data.brew_time_secs,
        category: recipe_data.category.clone(),
        effect_type: recipe_data.effect_type.clone(),
        icon_base64,
        created_at: ctx.timestamp,
    };
    
    cache.insert(cache_entry);
    
    log::info!(
        "[AI_BREWING] Cached recipe: hash={}, output_def_id={}, category={}, brew_time={}s",
        recipe_hash, output_def_id, recipe_data.category, recipe_data.brew_time_secs
    );
    
    Ok(())
}

/// Gets the cached recipe data for a given hash.
/// Used by the broth pot brewing logic to start cooking with the cached recipe.
pub fn get_cached_recipe(ctx: &ReducerContext, recipe_hash: u64) -> Option<BrewRecipeCache> {
    ctx.db.brew_recipe_cache().recipe_hash().find(recipe_hash)
}

/// Gets the output item definition for a cached recipe.
/// Returns the ItemDefinition that will be produced when brewing completes.
pub fn get_recipe_output_def(ctx: &ReducerContext, recipe_hash: u64) -> Option<ItemDefinition> {
    let cache = ctx.db.brew_recipe_cache();
    let item_defs = ctx.db.item_definition();
    
    if let Some(cached) = cache.recipe_hash().find(recipe_hash) {
        item_defs.id().find(cached.output_item_def_id)
    } else {
        None
    }
}

/// Helper to get ingredient names from broth pot slots.
/// Returns None if any slot is empty or ingredient not found.
pub fn get_broth_pot_ingredients(
    ctx: &ReducerContext,
    ingredient_def_ids: &[Option<u64>; 3],
) -> Option<Vec<String>> {
    let item_defs = ctx.db.item_definition();
    let mut ingredients = Vec::with_capacity(3);
    
    for def_id_opt in ingredient_def_ids {
        match def_id_opt {
            Some(def_id) => {
                if let Some(def) = item_defs.id().find(def_id) {
                    ingredients.push(def.name.clone());
                } else {
                    return None; // Ingredient definition not found
                }
            }
            None => return None, // Empty slot
        }
    }
    
    Some(ingredients)
}

/// Result of matching broth pot ingredients against the AI cache.
/// Contains all the info needed to start brewing.
#[derive(Clone, Debug)]
pub struct AiRecipeMatch {
    pub recipe_hash: u64,
    pub output_name: String,
    pub output_def_id: u64,
    pub brew_time_secs: u32,
    pub category: String,
    pub effect_type: Option<String>,
}

/// Try to match broth pot ingredients against the AI recipe cache.
/// Returns AiRecipeMatch if a cached recipe exists for the current ingredients.
/// 
/// This is called by broth_pot.rs to check if brewing can start.
/// If this returns None, the client needs to generate a new recipe via Gemini.
pub fn match_ai_recipe_from_broth_pot(
    ctx: &ReducerContext,
    ingredient_def_id_0: Option<u64>,
    ingredient_def_id_1: Option<u64>,
    ingredient_def_id_2: Option<u64>,
) -> Option<AiRecipeMatch> {
    // Get ingredient names from the broth pot slots
    let ingredient_def_ids = [ingredient_def_id_0, ingredient_def_id_1, ingredient_def_id_2];
    let ingredients = get_broth_pot_ingredients(ctx, &ingredient_def_ids)?;
    
    log::info!("[AI_BREWING] Checking cache for ingredients: {:?}", ingredients);
    
    // Compute the recipe hash
    let recipe_hash = compute_recipe_hash(&ingredients);
    
    // Look up in cache
    let cached = ctx.db.brew_recipe_cache().recipe_hash().find(recipe_hash)?;
    
    // Get the output item name
    let item_defs = ctx.db.item_definition();
    let output_def = item_defs.id().find(cached.output_item_def_id)?;
    
    log::info!(
        "[AI_BREWING] Cache HIT for ingredients {:?}: hash={}, output='{}'",
        ingredients, recipe_hash, output_def.name
    );
    
    Some(AiRecipeMatch {
        recipe_hash,
        output_name: output_def.name.clone(),
        output_def_id: cached.output_item_def_id,
        brew_time_secs: cached.brew_time_secs,
        category: cached.category.clone(),
        effect_type: cached.effect_type.clone(),
    })
}

/// Starts brewing using an AI-generated recipe match.
/// Called when a cached recipe is found for the broth pot ingredients.
pub fn start_ai_brewing(
    ctx: &ReducerContext,
    broth_pot_id: u32,
    recipe_match: &AiRecipeMatch,
) -> Result<(), String> {
    use crate::broth_pot::broth_pot as BrothPotTableTrait;
    use crate::sound_events;
    
    let mut broth_pot = ctx.db.broth_pot().id().find(broth_pot_id)
        .ok_or_else(|| format!("Broth pot {} not found", broth_pot_id))?;
    
    broth_pot.is_cooking = true;
    broth_pot.current_recipe_name = Some(recipe_match.output_name.clone());
    broth_pot.required_cooking_time_secs = recipe_match.brew_time_secs as f32;
    broth_pot.cooking_progress_secs = 0.0;
    
    ctx.db.broth_pot().id().update(broth_pot.clone());
    
    // Start boiling sound
    sound_events::start_soup_boiling_sound(ctx, broth_pot_id, broth_pot.pos_x, broth_pot.pos_y);
    
    log::info!(
        "[AI_BREWING] Started brewing '{}' in pot {} (brew_time={}s, category={})",
        recipe_match.output_name, broth_pot_id, recipe_match.brew_time_secs, recipe_match.category
    );
    
    Ok(())
}

// ============================================================================
// RE-EXPORTS FOR USE BY OTHER MODULES
// ============================================================================

pub use crate::ai_brewing::brew_recipe_cache as BrewRecipeCacheTableTrait;