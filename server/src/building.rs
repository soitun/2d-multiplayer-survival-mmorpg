/******************************************************************************
 *                                                                            *
 * Building System - Foundations, Walls, Doors                                *
 *                                                                            *
 * Handles placement, destruction, and management of building pieces.        *
 *                                                                            *
 ******************************************************************************/

use spacetimedb::{Identity, Timestamp, ReducerContext, Table, log};
use crate::{
    models::{FoundationShape, BuildingEdge, BuildingFacing, BuildingTier, TargetType, ItemLocation},
    environment::{calculate_chunk_index, is_position_on_water},
    TILE_SIZE_PX,
    world_pos_to_tile_coords,
};
use crate::player as PlayerTableTrait;
use crate::active_equipment::active_equipment as ActiveEquipmentTableTrait;
use crate::items::{item_definition as ItemDefinitionTableTrait, inventory_item as InventoryItemTableTrait};

// Import table traits
// Table trait will be auto-generated by SpacetimeDB

// --- Constants ---

// Building health constants (per tier)
// Twig tier: Easy to break with Combat Ladle (10 dmg/hit) - ~5-8 hits for foundations
pub const FOUNDATION_TWIG_MAX_HEALTH: f32 = 75.0;   // ~8 hits with Combat Ladle
pub const FOUNDATION_WOOD_MAX_HEALTH: f32 = 500.0; // ~50 hits (2x old Wood)
pub const FOUNDATION_STONE_MAX_HEALTH: f32 = 1000.0; // ~100 hits
pub const FOUNDATION_METAL_MAX_HEALTH: f32 = 2000.0; // ~200 hits

// Walls: Thinner than foundations, easier to break
pub const WALL_TWIG_MAX_HEALTH: f32 = 50.0;   // ~5 hits with Combat Ladle
pub const WALL_WOOD_MAX_HEALTH: f32 = 250.0;  // ~25 hits
pub const WALL_STONE_MAX_HEALTH: f32 = 500.0; // ~50 hits
pub const WALL_METAL_MAX_HEALTH: f32 = 1000.0; // ~100 hits

// Doorframes: Similar to walls but slightly weaker
pub const DOORFRAME_TWIG_MAX_HEALTH: f32 = 40.0;  // ~4 hits with Combat Ladle
pub const DOORFRAME_WOOD_MAX_HEALTH: f32 = 200.0; // ~20 hits
pub const DOORFRAME_STONE_MAX_HEALTH: f32 = 400.0; // ~40 hits
pub const DOORFRAME_METAL_MAX_HEALTH: f32 = 800.0; // ~80 hits

// Doors: Weakest building piece, easiest to break
pub const DOOR_TWIG_MAX_HEALTH: f32 = 30.0;  // ~3 hits with Combat Ladle
pub const DOOR_WOOD_MAX_HEALTH: f32 = 150.0; // ~15 hits
pub const DOOR_STONE_MAX_HEALTH: f32 = 300.0; // ~30 hits
pub const DOOR_METAL_MAX_HEALTH: f32 = 600.0; // ~60 hits

// Placement distance
pub const BUILDING_PLACEMENT_MAX_DISTANCE: f32 = 128.0;
pub const BUILDING_PLACEMENT_MAX_DISTANCE_SQUARED: f32 = BUILDING_PLACEMENT_MAX_DISTANCE * BUILDING_PLACEMENT_MAX_DISTANCE;

// Foundation grid is 2x world tiles (96px) for larger building pieces
pub const FOUNDATION_TILE_SIZE_PX: u32 = 96; // 2x TILE_SIZE_PX

// --- Foundation Cell Table ---
#[spacetimedb::table(
    name = foundation_cell,
    public,
    index(name = idx_chunk, btree(columns = [chunk_index])),
    index(name = idx_cell_coords, btree(columns = [cell_x, cell_y]))
)]
#[derive(Clone, Debug)]
pub struct FoundationCell {
    #[primary_key]
    #[auto_inc]
    pub id: u64,
    pub cell_x: i32,  // Foundation cell X coordinate (96px grid, 2x world tiles)
    pub cell_y: i32,  // Foundation cell Y coordinate (96px grid, 2x world tiles)
    pub chunk_index: u32,  // For chunk-based spatial subscriptions
    pub shape: u8,    // FoundationShape enum (0-5)
    pub tier: u8,     // BuildingTier enum (0-3: Twig, Wood, Stone, Metal)
    pub health: f32,
    pub max_health: f32,
    pub owner: Identity,
    pub placed_at: Timestamp,
    pub is_destroyed: bool,
    pub destroyed_at: Option<Timestamp>,
    pub last_hit_time: Option<Timestamp>,
    pub last_damaged_by: Option<Identity>,
    pub group_id: Option<i64>,  // For future building groups/clans
}

// --- Wall Cell Table ---
#[spacetimedb::table(
    name = wall_cell,
    public,
    index(name = idx_chunk, btree(columns = [chunk_index])),
    index(name = idx_cell_coords, btree(columns = [cell_x, cell_y]))
)]
#[derive(Clone, Debug)]
pub struct WallCell {
    #[primary_key]
    #[auto_inc]
    pub id: u64,
    pub cell_x: i32,  // Foundation cell X coordinate (wall is on edge of this foundation cell)
    pub cell_y: i32,  // Foundation cell Y coordinate (96px grid, 2x world tiles)
    pub chunk_index: u32,  // For chunk-based spatial subscriptions
    pub edge: u8,     // BuildingEdge enum (0-3: N, E, S, W)
    pub facing: u8,   // BuildingFacing enum (0: Interior, 1: Exterior)
    pub foundation_shape: u8,  // FoundationShape enum (0-5) - which foundation this wall is on
    pub tier: u8,     // BuildingTier enum (0-3: Twig, Wood, Stone, Metal)
    pub health: f32,
    pub max_health: f32,
    pub owner: Identity,
    pub placed_at: Timestamp,
    pub is_destroyed: bool,
    pub destroyed_at: Option<Timestamp>,
    pub last_hit_time: Option<Timestamp>,
    pub last_damaged_by: Option<Identity>,
    pub group_id: Option<i64>,  // For future building groups/clans
}

// --- Helper Functions ---

/// Check if player has Blueprint equipped
pub fn player_has_blueprint(ctx: &ReducerContext, player_id: Identity) -> bool {
    let active_equipments = ctx.db.active_equipment();
    let item_defs = ctx.db.item_definition();
    
    if let Some(equipment) = active_equipments.player_identity().find(&player_id) {
        if let Some(item_def_id) = equipment.equipped_item_def_id {
            if let Some(item_def) = item_defs.id().find(&item_def_id) {
                return item_def.name == "Blueprint";
            }
        }
    }
    
    false
}

/// Check if player has Repair Hammer equipped
pub fn player_has_repair_hammer(ctx: &ReducerContext, player_id: Identity) -> bool {
    let active_equipments = ctx.db.active_equipment();
    let item_defs = ctx.db.item_definition();
    
    if let Some(equipment) = active_equipments.player_identity().find(&player_id) {
        if let Some(item_def_id) = equipment.equipped_item_def_id {
            if let Some(item_def) = item_defs.id().find(&item_def_id) {
                return item_def.name == "Repair Hammer";
            }
        }
    }
    
    false
}

/// Get foundation max health based on tier
pub fn get_foundation_max_health(tier: BuildingTier) -> f32 {
    match tier {
        BuildingTier::Twig => FOUNDATION_TWIG_MAX_HEALTH,
        BuildingTier::Wood => FOUNDATION_WOOD_MAX_HEALTH,
        BuildingTier::Stone => FOUNDATION_STONE_MAX_HEALTH,
        BuildingTier::Metal => FOUNDATION_METAL_MAX_HEALTH,
    }
}

/// Get wall max health based on tier
pub fn get_wall_max_health(tier: BuildingTier) -> f32 {
    match tier {
        BuildingTier::Twig => WALL_TWIG_MAX_HEALTH,
        BuildingTier::Wood => WALL_WOOD_MAX_HEALTH,
        BuildingTier::Stone => WALL_STONE_MAX_HEALTH,
        BuildingTier::Metal => WALL_METAL_MAX_HEALTH,
    }
}

/// Get doorframe max health based on tier
pub fn get_doorframe_max_health(tier: BuildingTier) -> f32 {
    match tier {
        BuildingTier::Twig => DOORFRAME_TWIG_MAX_HEALTH,
        BuildingTier::Wood => DOORFRAME_WOOD_MAX_HEALTH,
        BuildingTier::Stone => DOORFRAME_STONE_MAX_HEALTH,
        BuildingTier::Metal => DOORFRAME_METAL_MAX_HEALTH,
    }
}

/// Get door max health based on tier
pub fn get_door_max_health(tier: BuildingTier) -> f32 {
    match tier {
        BuildingTier::Twig => DOOR_TWIG_MAX_HEALTH,
        BuildingTier::Wood => DOOR_WOOD_MAX_HEALTH,
        BuildingTier::Stone => DOOR_STONE_MAX_HEALTH,
        BuildingTier::Metal => DOOR_METAL_MAX_HEALTH,
    }
}

/// Validate foundation shape enum value
pub fn is_valid_foundation_shape(shape: u8) -> bool {
    matches!(shape, 0..=5) // Empty, Full, TriNW, TriNE, TriSE, TriSW
}

/// Validate building tier enum value
pub fn is_valid_building_tier(tier: u8) -> bool {
    matches!(tier, 0..=3) // Twig, Wood, Stone, Metal
}

/// Validate building edge enum value
pub fn is_valid_building_edge(edge: u8) -> bool {
    matches!(edge, 0..=3) // N, E, S, W (diagonals not used for walls)
}

/// Validate building facing enum value
pub fn is_valid_building_facing(facing: u8) -> bool {
    matches!(facing, 0..=1) // Interior, Exterior
}

/// Determine which edge a wall should be placed on based on mouse position relative to tile center
/// Returns (edge, facing) where edge is BuildingEdge and facing is BuildingFacing
/// For triangle foundations, also considers diagonal edges
pub fn determine_wall_edge_and_facing(
    world_x: f32,
    world_y: f32,
    cell_x: i32,
    cell_y: i32,
    player_x: f32,
    player_y: f32,
    foundation_shape: FoundationShape,
) -> (BuildingEdge, BuildingFacing) {
    // Calculate foundation cell center (96px grid)
    let tile_center_x = (cell_x as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
    let tile_center_y = (cell_y as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
    
    // Calculate offset from tile center
    let dx = world_x - tile_center_x;
    let dy = world_y - tile_center_y;
    
    // Determine which edge is closest (snap to nearest edge)
    let abs_dx = dx.abs();
    let abs_dy = dy.abs();
    
    // For triangle foundations, also consider diagonal edges
    let is_triangle = matches!(foundation_shape, FoundationShape::TriNW | FoundationShape::TriNE | FoundationShape::TriSE | FoundationShape::TriSW);
    
    let (edge, facing) = if is_triangle {
        // Calculate distance to diagonal edges
        let diag_nw_se_dist = (dx - dy).abs(); // Distance to NW-SE diagonal
        let diag_ne_sw_dist = (dx + dy).abs(); // Distance to NE-SW diagonal
        
        // Check if we're closer to a diagonal than to cardinal edges
        let min_cardinal_dist = abs_dx.min(abs_dy);
        let min_diag_dist = diag_nw_se_dist.min(diag_ne_sw_dist);
        
        if min_diag_dist < min_cardinal_dist {
            // Closer to diagonal
            if diag_nw_se_dist < diag_ne_sw_dist {
                // DiagNW_SE (edge 5)
                let facing = if player_x < tile_center_x && player_y < tile_center_y {
                    BuildingFacing::Interior
                } else {
                    BuildingFacing::Exterior
                };
                (BuildingEdge::DiagNW_SE, facing)
            } else {
                // DiagNE_SW (edge 4)
                let facing = if player_x > tile_center_x && player_y < tile_center_y {
                    BuildingFacing::Interior
                } else {
                    BuildingFacing::Exterior
                };
                (BuildingEdge::DiagNE_SW, facing)
            }
        } else {
            // Closer to cardinal edge
            if abs_dy > abs_dx {
                if dy < 0.0 {
                    let facing = if player_y < tile_center_y {
                        BuildingFacing::Interior
                    } else {
                        BuildingFacing::Exterior
                    };
                    (BuildingEdge::N, facing)
                } else {
                    let facing = if player_y > tile_center_y {
                        BuildingFacing::Interior
                    } else {
                        BuildingFacing::Exterior
                    };
                    (BuildingEdge::S, facing)
                }
            } else {
                if dx < 0.0 {
                    let facing = if player_x < tile_center_x {
                        BuildingFacing::Interior
                    } else {
                        BuildingFacing::Exterior
                    };
                    (BuildingEdge::W, facing)
                } else {
                    let facing = if player_x > tile_center_x {
                        BuildingFacing::Interior
                    } else {
                        BuildingFacing::Exterior
                    };
                    (BuildingEdge::E, facing)
                }
            }
        }
    } else {
        // Full foundation - only cardinal edges
        if abs_dy > abs_dx {
            if dy < 0.0 {
                let facing = if player_y < tile_center_y {
                    BuildingFacing::Interior
                } else {
                    BuildingFacing::Exterior
                };
                (BuildingEdge::N, facing)
            } else {
                let facing = if player_y > tile_center_y {
                    BuildingFacing::Interior
                } else {
                    BuildingFacing::Exterior
                };
                (BuildingEdge::S, facing)
            }
        } else {
            if dx < 0.0 {
                let facing = if player_x < tile_center_x {
                    BuildingFacing::Interior
                } else {
                    BuildingFacing::Exterior
                };
                (BuildingEdge::W, facing)
            } else {
                let facing = if player_x > tile_center_x {
                    BuildingFacing::Interior
                } else {
                    BuildingFacing::Exterior
                };
                (BuildingEdge::E, facing)
            }
        }
    };
    
    (edge, facing)
}

/// Check if a wall position is valid (foundation exists, no overlapping wall)
pub fn is_wall_position_valid(
    ctx: &ReducerContext,
    cell_x: i32,
    cell_y: i32,
    edge: BuildingEdge,
    facing: BuildingFacing,
) -> Result<(), String> {
    // 1. Check if there's a foundation at this cell
    let foundations = ctx.db.foundation_cell();
    let mut foundation_found = false;
    let mut foundation_shape = FoundationShape::Full;
    
    for foundation in foundations.idx_cell_coords().filter((cell_x, cell_y)) {
        if !foundation.is_destroyed {
            foundation_found = true;
            foundation_shape = match foundation.shape {
                0 => FoundationShape::Empty,
                1 => FoundationShape::Full,
                2 => FoundationShape::TriNW,
                3 => FoundationShape::TriNE,
                4 => FoundationShape::TriSE,
                5 => FoundationShape::TriSW,
                _ => continue,
            };
            break;
        }
    }
    
    if !foundation_found {
        return Err("Cannot place wall: no foundation at this location.".to_string());
    }
    
    // 2. For triangle foundations, check if the edge is valid
    match foundation_shape {
        FoundationShape::TriNW => {
            // Valid edges: N, W, DiagNW_SE
            if !matches!(edge, BuildingEdge::N | BuildingEdge::W | BuildingEdge::DiagNW_SE) {
                return Err("Invalid edge for triangle foundation (TriNW).".to_string());
            }
        }
        FoundationShape::TriNE => {
            // Valid edges: N, E, DiagNE_SW
            if !matches!(edge, BuildingEdge::N | BuildingEdge::E | BuildingEdge::DiagNE_SW) {
                return Err("Invalid edge for triangle foundation (TriNE).".to_string());
            }
        }
        FoundationShape::TriSE => {
            // Valid edges: S, E, DiagNW_SE
            if !matches!(edge, BuildingEdge::S | BuildingEdge::E | BuildingEdge::DiagNW_SE) {
                return Err("Invalid edge for triangle foundation (TriSE).".to_string());
            }
        }
        FoundationShape::TriSW => {
            // Valid edges: S, W, DiagNE_SW
            if !matches!(edge, BuildingEdge::S | BuildingEdge::W | BuildingEdge::DiagNE_SW) {
                return Err("Invalid edge for triangle foundation (TriSW).".to_string());
            }
        }
        _ => {
            // Full foundation - all edges valid
        }
    }
    
    // 3. Check if there's already a wall at this edge/facing combination
    // Also check adjacent tiles for shared edges
    let walls = ctx.db.wall_cell();
    
    // Check current cell - don't check facing, just edge (walls on same edge block regardless of facing)
    for wall in walls.idx_cell_coords().filter((cell_x, cell_y)) {
        if !wall.is_destroyed && wall.edge == edge as u8 {
            return Err("A wall already exists at this edge.".to_string());
        }
    }
    
    // Check adjacent tiles for shared edges
    // North edge of (x, y) = South edge of (x, y-1)
    // East edge of (x, y) = West edge of (x+1, y)
    // South edge of (x, y) = North edge of (x, y+1)
    // West edge of (x, y) = East edge of (x-1, y)
    let (adjacent_cell_x, adjacent_cell_y, opposite_edge) = match edge {
        BuildingEdge::N => (cell_x, cell_y - 1, BuildingEdge::S as u8),
        BuildingEdge::E => (cell_x + 1, cell_y, BuildingEdge::W as u8),
        BuildingEdge::S => (cell_x, cell_y + 1, BuildingEdge::N as u8),
        BuildingEdge::W => (cell_x - 1, cell_y, BuildingEdge::E as u8),
        _ => {
            // Diagonal edges don't have adjacent tiles (they're internal to the triangle)
            return Ok(());
        }
    };
    
    // Check adjacent cell for a wall on the opposite edge (any facing - shared edge is shared)
    for wall in walls.idx_cell_coords().filter((adjacent_cell_x, adjacent_cell_y)) {
        if !wall.is_destroyed && wall.edge == opposite_edge {
            return Err("A wall already exists on the shared edge with the adjacent tile.".to_string());
        }
    }
    
    Ok(())
}

/// Check if a foundation cell position is valid (not overlapping with existing foundation)
pub fn is_foundation_position_valid(
    ctx: &ReducerContext,
    cell_x: i32,
    cell_y: i32,
    shape: FoundationShape,
) -> bool {
    let foundations = ctx.db.foundation_cell();
    
    // IMPORTANT: Check ALL foundations at this cell - there might be two complementary triangles already
    let mut found_complementary = false;
    let mut found_overlap = false;
    let mut foundation_count = 0;
    
    // Check if there's already a foundation at this cell
    for foundation in foundations.idx_cell_coords().filter((cell_x, cell_y)) {
        // If there's an existing foundation and it's not destroyed
        if !foundation.is_destroyed {
            foundation_count += 1;
            
            // Convert stored u8 shape to FoundationShape enum for comparison
            let existing_shape = match foundation.shape {
                0 => FoundationShape::Empty,
                1 => FoundationShape::Full,
                2 => FoundationShape::TriNW,
                3 => FoundationShape::TriNE,
                4 => FoundationShape::TriSE,
                5 => FoundationShape::TriSW,
                _ => continue, // Invalid shape, skip
            };
            
            // Check if shapes are compatible (triangles can merge into Full)
            match (shape, existing_shape) {
                (FoundationShape::Full, FoundationShape::Full) => return false, // Overlap
                (FoundationShape::TriNW, FoundationShape::TriNW) => return false, // Overlap
                (FoundationShape::TriNE, FoundationShape::TriNE) => return false, // Overlap
                (FoundationShape::TriSE, FoundationShape::TriSE) => return false, // Overlap
                (FoundationShape::TriSW, FoundationShape::TriSW) => return false, // Overlap
                // Complementary triangles can be placed together to form a full square
                (FoundationShape::TriNW, FoundationShape::TriSE) => found_complementary = true, // Compatible
                (FoundationShape::TriSE, FoundationShape::TriNW) => found_complementary = true, // Compatible
                (FoundationShape::TriNE, FoundationShape::TriSW) => found_complementary = true, // Compatible
                (FoundationShape::TriSW, FoundationShape::TriNE) => found_complementary = true, // Compatible
                // Full foundation overlaps with any triangle
                (FoundationShape::Full, _) => return false, // Full overlaps with anything
                (_, FoundationShape::Full) => return false, // Full overlaps with anything
                // Non-complementary triangles overlap
                _ => found_overlap = true, // Different shapes overlap
            }
        }
    }
    
    // If we found an overlap, block placement
    if found_overlap {
        return false;
    }
    
    // If there are already 2 foundations at this cell (two complementary triangles forming a full square),
    // block any further placement
    if foundation_count >= 2 {
        return false; // Already have two triangles forming a full square
    }
    
    // If we found a complementary triangle and no overlaps, allow placement
    // (This handles the case where we're adding the second triangle to form a full square)
    // If no foundations found at all, allow placement
    true
}

// --- Reducers ---

/// Place a foundation cell at the specified tile coordinates
#[spacetimedb::reducer]
pub fn place_foundation(
    ctx: &ReducerContext,
    cell_x: i64,
    cell_y: i64,
    shape: u8,
    tier: u8,
) -> Result<(), String> {
    let sender_id = ctx.sender;
    let players = ctx.db.player();
    let foundations = ctx.db.foundation_cell();
    
    log::info!(
        "[PlaceFoundation] Player {:?} attempting to place foundation at cell ({}, {}), shape={}, tier={}",
        sender_id, cell_x, cell_y, shape, tier
    );
    
    // 1. Validate player
    let player = players.identity().find(&sender_id)
        .ok_or_else(|| "Player not found".to_string())?;
    
    if player.is_dead {
        return Err("Cannot place foundation while dead.".to_string());
    }
    
    if player.is_knocked_out {
        return Err("Cannot place foundation while knocked out.".to_string());
    }
    
    // 2. Validate Blueprint equipped
    if !player_has_blueprint(ctx, sender_id) {
        return Err("Blueprint must be equipped to place building pieces.".to_string());
    }
    
    // 3. Validate shape and tier enum values
    if !is_valid_foundation_shape(shape) {
        return Err(format!("Invalid foundation shape: {}. Must be 0-5.", shape));
    }
    
    if !is_valid_building_tier(tier) {
        return Err(format!("Invalid building tier: {}. Must be 0-3 (Twig, Wood, Stone, Metal).", tier));
    }
    
    let foundation_shape = match shape {
        0 => FoundationShape::Empty,
        1 => FoundationShape::Full,
        2 => FoundationShape::TriNW,
        3 => FoundationShape::TriNE,
        4 => FoundationShape::TriSE,
        5 => FoundationShape::TriSW,
        _ => return Err("Invalid foundation shape".to_string()),
    };
    
    let building_tier = match tier {
        0 => BuildingTier::Twig,
        1 => BuildingTier::Wood,
        2 => BuildingTier::Stone,
        3 => BuildingTier::Metal,
        _ => return Err("Invalid building tier".to_string()),
    };
    
    // 4. Validate position (check for overlaps)
    let cell_x_i32 = cell_x as i32;
    let cell_y_i32 = cell_y as i32;
    if !is_foundation_position_valid(ctx, cell_x_i32, cell_y_i32, foundation_shape) {
        return Err(format!("Cannot place foundation at ({}, {}): position already occupied or invalid.", cell_x, cell_y));
    }
    
    // 5. Check if position is on water (foundations cannot be placed on water tiles)
    // Convert foundation cell coordinates to world pixel coordinates (center of foundation cell)
    let world_x = (cell_x_i32 as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
    let world_y = (cell_y_i32 as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
    
    if is_position_on_water(ctx, world_x, world_y) {
        return Err("Cannot place foundation on water tiles.".to_string());
    }
    
    // 6. Check placement distance from player
    let dx = world_x - player.position_x;
    let dy = world_y - player.position_y;
    let dist_sq = dx * dx + dy * dy;
    
    if dist_sq > BUILDING_PLACEMENT_MAX_DISTANCE_SQUARED {
        return Err(format!(
            "Foundation placement too far from player. Distance: {:.1}px, Max: {:.1}px",
            dist_sq.sqrt(),
            BUILDING_PLACEMENT_MAX_DISTANCE
        ));
    }
    
    // 7. Calculate chunk index
    let chunk_index = calculate_chunk_index(world_x, world_y);
    
    // 8. Get max health for this tier
    let max_health = get_foundation_max_health(building_tier);
    
    // 9. Check and consume resources (Twig tier uses wood, cost depends on shape: 50 for full, 25 for triangles)
    let required_wood = match foundation_shape {
        FoundationShape::Full => 50,
        FoundationShape::TriNW | FoundationShape::TriNE | FoundationShape::TriSE | FoundationShape::TriSW => 25,
        _ => 50, // Default to 50 for unknown shapes
    };
    
    let inventory = ctx.db.inventory_item();
    let item_defs = ctx.db.item_definition();
    
    // Find "Wood" item definition
    let wood_item_def = item_defs.iter()
        .find(|def| def.name == "Wood")
        .ok_or_else(|| "Wood item definition not found".to_string())?;
    
    // Find wood items in player's inventory OR hotbar
    let mut wood_items: Vec<_> = inventory.iter()
        .filter(|item| {
            let is_owned = match &item.location {
                ItemLocation::Inventory(data) => data.owner_id == sender_id,
                ItemLocation::Hotbar(data) => data.owner_id == sender_id,
                _ => false,
            };
            is_owned &&
            item.item_def_id == wood_item_def.id &&
            item.quantity > 0
        })
        .collect();
    
    // Calculate total wood available
    let total_wood: u32 = wood_items.iter().map(|item| item.quantity).sum();
    
    if total_wood < required_wood {
        return Err(format!(
            "Not enough wood. Required: {}, Available: {}",
            required_wood, total_wood
        ));
    }
    
    // Consume wood (remove from inventory, starting with first item)
    let mut remaining_to_consume = required_wood;
    for wood_item in &wood_items {
        if remaining_to_consume == 0 {
            break;
        }
        
        let consume_from_this = remaining_to_consume.min(wood_item.quantity);
        let new_quantity = wood_item.quantity - consume_from_this;
        remaining_to_consume -= consume_from_this;
        
        if new_quantity == 0 {
            // Delete item if quantity reaches 0
            ctx.db.inventory_item().instance_id().delete(wood_item.instance_id);
        } else {
            // Update item with new quantity
            let mut updated_item = wood_item.clone();
            updated_item.quantity = new_quantity;
            ctx.db.inventory_item().instance_id().update(updated_item);
        }
    }
    
    log::info!("[PlaceFoundation] Consumed {} wood from player {:?}", required_wood, sender_id);
    
    // 9. Create and insert foundation
    let new_foundation = FoundationCell {
        id: 0, // Auto-incremented
        cell_x: cell_x_i32,
        cell_y: cell_y_i32,
        chunk_index,
        shape,
        tier,
        health: max_health,
        max_health,
        owner: sender_id,
        placed_at: ctx.timestamp,
        is_destroyed: false,
        destroyed_at: None,
        last_hit_time: None,
        last_damaged_by: None,
        group_id: None, // TODO: Implement group system
    };
    
    foundations.try_insert(new_foundation)
        .map_err(|e| format!("Failed to insert foundation: {}", e))?;
    
    // 10. Emit foundation construction sound for all nearby players
    crate::sound_events::emit_foundation_wood_constructed_sound(ctx, world_x, world_y, sender_id);
    
    log::info!(
        "[PlaceFoundation] Successfully placed foundation at cell ({}, {}), tier={:?}, health={:.1}",
        cell_x, cell_y, building_tier, max_health
    );
    
    Ok(())
}

/// Upgrade a foundation to a higher tier
#[spacetimedb::reducer]
pub fn upgrade_foundation(
    ctx: &ReducerContext,
    foundation_id: u64,
    new_tier: u8,
) -> Result<(), String> {
    let sender_id = ctx.sender;
    let players = ctx.db.player();
    let foundations = ctx.db.foundation_cell();
    
    log::info!(
        "[UpgradeFoundation] Player {:?} attempting to upgrade foundation {} to tier {}",
        sender_id, foundation_id, new_tier
    );
    
    // 1. Validate player
    let player = players.identity().find(&sender_id)
        .ok_or_else(|| "Player not found".to_string())?;
    
    if player.is_dead {
        return Err("Cannot upgrade foundation while dead.".to_string());
    }
    
    if player.is_knocked_out {
        return Err("Cannot upgrade foundation while knocked out.".to_string());
    }
    
    // 2. Validate Repair Hammer equipped
    if !player_has_repair_hammer(ctx, sender_id) {
        return Err("Repair Hammer must be equipped to upgrade foundations.".to_string());
    }
    
    // 3. Find foundation
    let foundation = foundations.id().find(&foundation_id)
        .ok_or_else(|| "Foundation not found".to_string())?;
    
    if foundation.is_destroyed {
        return Err("Cannot upgrade destroyed foundation.".to_string());
    }
    
    // 4. Validate new tier
    if !is_valid_building_tier(new_tier) {
        return Err(format!("Invalid building tier: {}. Must be 0-3 (Twig, Wood, Stone, Metal).", new_tier));
    }
    
    let current_tier = match foundation.tier {
        0 => BuildingTier::Twig,
        1 => BuildingTier::Wood,
        2 => BuildingTier::Stone,
        3 => BuildingTier::Metal,
        _ => return Err("Foundation has invalid tier".to_string()),
    };
    
    let target_tier = match new_tier {
        0 => BuildingTier::Twig,
        1 => BuildingTier::Wood,
        2 => BuildingTier::Stone,
        3 => BuildingTier::Metal,
        _ => return Err("Invalid target tier".to_string()),
    };
    
    // 5. Check if upgrade is valid (can only upgrade to higher tier)
    if target_tier as u8 <= current_tier as u8 {
        return Err(format!("Cannot downgrade foundation. Current tier: {:?}, Target tier: {:?}", current_tier, target_tier));
    }
    
    // 6. Check placement distance from player
    let world_x = (foundation.cell_x as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
    let world_y = (foundation.cell_y as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
    
    let dx = world_x - player.position_x;
    let dy = world_y - player.position_y;
    let dist_sq = dx * dx + dy * dy;
    
    if dist_sq > BUILDING_PLACEMENT_MAX_DISTANCE_SQUARED {
        return Err(format!(
            "Foundation upgrade too far from player. Distance: {:.1}px, Max: {:.1}px",
            dist_sq.sqrt(),
            BUILDING_PLACEMENT_MAX_DISTANCE
        ));
    }
    
    // 7. Calculate resource costs based on target tier and shape
    let inventory = ctx.db.inventory_item();
    let item_defs = ctx.db.item_definition();
    
    // Determine shape for cost calculation
    let foundation_shape = match foundation.shape {
        0 => FoundationShape::Empty,
        1 => FoundationShape::Full,
        2 => FoundationShape::TriNW,
        3 => FoundationShape::TriNE,
        4 => FoundationShape::TriSE,
        5 => FoundationShape::TriSW,
        _ => return Err("Foundation has invalid shape".to_string()),
    };
    
    let shape_multiplier = match foundation_shape {
        FoundationShape::Full => 1.0,
        FoundationShape::TriNW | FoundationShape::TriNE | FoundationShape::TriSE | FoundationShape::TriSW => 0.5,
        _ => 1.0,
    };
    
    // Resource costs per tier upgrade
    let (required_wood, required_stone, required_metal) = match target_tier {
        BuildingTier::Wood => {
            // Twig -> Wood: 50 wood for full, 25 for triangle
            ((50.0 * shape_multiplier) as u32, 0, 0)
        },
        BuildingTier::Stone => {
            // -> Stone: 100 stone for full, 50 for triangle
            (0, (100.0 * shape_multiplier) as u32, 0)
        },
        BuildingTier::Metal => {
            // -> Metal: 50 metal fragments for full, 25 for triangle
            (0, 0, (50.0 * shape_multiplier) as u32)
        },
        BuildingTier::Twig => {
            // Can't upgrade to Twig (it's the base tier)
            return Err("Cannot upgrade to Twig tier".to_string());
        },
    };
    
    // 8. Check and consume resources
    if required_wood > 0 {
        let wood_item_def = item_defs.iter()
            .find(|def| def.name == "Wood")
            .ok_or_else(|| "Wood item definition not found".to_string())?;
        
        let mut wood_items: Vec<_> = inventory.iter()
            .filter(|item| {
                let is_owned = match &item.location {
                    ItemLocation::Inventory(data) => data.owner_id == sender_id,
                    ItemLocation::Hotbar(data) => data.owner_id == sender_id,
                    _ => false,
                };
                is_owned &&
                item.item_def_id == wood_item_def.id &&
                item.quantity > 0
            })
            .collect();
        
        let total_wood: u32 = wood_items.iter().map(|item| item.quantity).sum();
        
        if total_wood < required_wood {
            return Err(format!(
                "Not enough wood. Required: {}, Available: {}",
                required_wood, total_wood
            ));
        }
        
        // Consume wood
        let mut remaining_to_consume = required_wood;
        for wood_item in &wood_items {
            if remaining_to_consume == 0 {
                break;
            }
            
            let consume_from_this = remaining_to_consume.min(wood_item.quantity);
            let new_quantity = wood_item.quantity - consume_from_this;
            remaining_to_consume -= consume_from_this;
            
            if new_quantity == 0 {
                ctx.db.inventory_item().instance_id().delete(wood_item.instance_id);
            } else {
                let mut updated_item = wood_item.clone();
                updated_item.quantity = new_quantity;
                ctx.db.inventory_item().instance_id().update(updated_item);
            }
        }
        
        log::info!("[UpgradeFoundation] Consumed {} wood from player {:?}", required_wood, sender_id);
    }
    
    if required_stone > 0 {
        let stone_item_def = item_defs.iter()
            .find(|def| def.name == "Stone")
            .ok_or_else(|| "Stone item definition not found".to_string())?;
        
        let mut stone_items: Vec<_> = inventory.iter()
            .filter(|item| {
                let is_owned = match &item.location {
                    ItemLocation::Inventory(data) => data.owner_id == sender_id,
                    ItemLocation::Hotbar(data) => data.owner_id == sender_id,
                    _ => false,
                };
                is_owned &&
                item.item_def_id == stone_item_def.id &&
                item.quantity > 0
            })
            .collect();
        
        let total_stone: u32 = stone_items.iter().map(|item| item.quantity).sum();
        
        if total_stone < required_stone {
            return Err(format!(
                "Not enough stone. Required: {}, Available: {}",
                required_stone, total_stone
            ));
        }
        
        // Consume stone
        let mut remaining_to_consume = required_stone;
        for stone_item in &stone_items {
            if remaining_to_consume == 0 {
                break;
            }
            
            let consume_from_this = remaining_to_consume.min(stone_item.quantity);
            let new_quantity = stone_item.quantity - consume_from_this;
            remaining_to_consume -= consume_from_this;
            
            if new_quantity == 0 {
                ctx.db.inventory_item().instance_id().delete(stone_item.instance_id);
            } else {
                let mut updated_item = stone_item.clone();
                updated_item.quantity = new_quantity;
                ctx.db.inventory_item().instance_id().update(updated_item);
            }
        }
        
        log::info!("[UpgradeFoundation] Consumed {} stone from player {:?}", required_stone, sender_id);
    }
    
    if required_metal > 0 {
        let metal_item_def = item_defs.iter()
            .find(|def| def.name == "Metal Fragments")
            .ok_or_else(|| "Metal Fragments item definition not found".to_string())?;
        
        let mut metal_items: Vec<_> = inventory.iter()
            .filter(|item| {
                let is_owned = match &item.location {
                    ItemLocation::Inventory(data) => data.owner_id == sender_id,
                    ItemLocation::Hotbar(data) => data.owner_id == sender_id,
                    _ => false,
                };
                is_owned &&
                item.item_def_id == metal_item_def.id &&
                item.quantity > 0
            })
            .collect();
        
        let total_metal: u32 = metal_items.iter().map(|item| item.quantity).sum();
        
        if total_metal < required_metal {
            return Err(format!(
                "Not enough metal fragments. Required: {}, Available: {}",
                required_metal, total_metal
            ));
        }
        
        // Consume metal
        let mut remaining_to_consume = required_metal;
        for metal_item in &metal_items {
            if remaining_to_consume == 0 {
                break;
            }
            
            let consume_from_this = remaining_to_consume.min(metal_item.quantity);
            let new_quantity = metal_item.quantity - consume_from_this;
            remaining_to_consume -= consume_from_this;
            
            if new_quantity == 0 {
                ctx.db.inventory_item().instance_id().delete(metal_item.instance_id);
            } else {
                let mut updated_item = metal_item.clone();
                updated_item.quantity = new_quantity;
                ctx.db.inventory_item().instance_id().update(updated_item);
            }
        }
        
        log::info!("[UpgradeFoundation] Consumed {} metal fragments from player {:?}", required_metal, sender_id);
    }
    
    // 9. Update foundation tier and health
    let new_max_health = get_foundation_max_health(target_tier);
    let health_ratio = foundation.health / foundation.max_health;
    let new_health = new_max_health * health_ratio; // Preserve health percentage
    
    let mut updated_foundation = foundation.clone();
    updated_foundation.tier = new_tier;
    updated_foundation.max_health = new_max_health;
    updated_foundation.health = new_health;
    
    foundations.id().update(updated_foundation);
    
    // 10. Emit upgrade sound based on tier
    match target_tier {
        BuildingTier::Wood => {
            crate::sound_events::emit_foundation_wood_upgraded_sound(ctx, world_x, world_y, sender_id);
        },
        BuildingTier::Stone => {
            crate::sound_events::emit_foundation_stone_upgraded_sound(ctx, world_x, world_y, sender_id);
        },
        BuildingTier::Metal => {
            crate::sound_events::emit_foundation_metal_upgraded_sound(ctx, world_x, world_y, sender_id);
        },
        BuildingTier::Twig => {
            // Should not happen, but handle it
        },
    }
    
    log::info!(
        "[UpgradeFoundation] Successfully upgraded foundation {} from {:?} to {:?}, health={:.1}/{:.1}",
        foundation_id, current_tier, target_tier, new_health, new_max_health
    );
    
    Ok(())
}

/// Destroy a twig foundation (only twig foundations can be destroyed)
#[spacetimedb::reducer]
pub fn destroy_foundation(ctx: &ReducerContext, foundation_id: u64) -> Result<(), String> {
    use crate::sound_events;
    
    let sender_id = ctx.sender;
    let foundations = ctx.db.foundation_cell();
    let players = ctx.db.player();
    
    // 1. Validate player exists and is not knocked out
    let player = players.identity().find(&sender_id)
        .ok_or_else(|| "Player not found".to_string())?;
    
    if player.is_knocked_out {
        return Err("Cannot destroy foundation while knocked out.".to_string());
    }
    
    // 2. Validate Repair Hammer equipped
    if !player_has_repair_hammer(ctx, sender_id) {
        return Err("Repair Hammer must be equipped to destroy foundations.".to_string());
    }
    
    // 3. Find foundation
    let foundation = foundations.id().find(&foundation_id)
        .ok_or_else(|| "Foundation not found".to_string())?;
    
    if foundation.is_destroyed {
        return Err("Foundation is already destroyed.".to_string());
    }
    
    // 4. Only twig foundations can be destroyed
    if foundation.tier != 0 {
        return Err("Only twig foundations can be destroyed.".to_string());
    }
    
    // 5. Check placement distance from player
    let world_x = (foundation.cell_x as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
    let world_y = (foundation.cell_y as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
    
    let dx = world_x - player.position_x;
    let dy = world_y - player.position_y;
    let dist_sq = dx * dx + dy * dy;
    
    if dist_sq > BUILDING_PLACEMENT_MAX_DISTANCE_SQUARED {
        return Err("Foundation is too far away.".to_string());
    }
    
    // 6. Mark foundation as destroyed
    let mut updated_foundation = foundation.clone();
    updated_foundation.is_destroyed = true;
    updated_foundation.destroyed_at = Some(ctx.timestamp);
    
    foundations.id().update(updated_foundation);
    
    // 7. Emit destroy sound
    sound_events::emit_foundation_twig_destroyed_sound(ctx, world_x, world_y, sender_id);
    
    log::info!(
        "[DestroyFoundation] Successfully destroyed twig foundation {} at ({}, {})",
        foundation_id, foundation.cell_x, foundation.cell_y
    );
    
    Ok(())
}

/// Place a wall cell on the edge of a foundation tile
#[spacetimedb::reducer]
pub fn place_wall(
    ctx: &ReducerContext,
    cell_x: i64,
    cell_y: i64,
    world_x: f32,
    world_y: f32,
    tier: u8,
) -> Result<(), String> {
    let sender_id = ctx.sender;
    let players = ctx.db.player();
    let walls = ctx.db.wall_cell();
    let foundations = ctx.db.foundation_cell();
    
    log::info!(
        "[PlaceWall] Player {:?} attempting to place wall at cell ({}, {}), world=({:.1}, {:.1}), tier={}",
        sender_id, cell_x, cell_y, world_x, world_y, tier
    );
    
    // 1. Validate player
    let player = players.identity().find(&sender_id)
        .ok_or_else(|| "Player not found".to_string())?;
    
    if player.is_dead {
        return Err("Cannot place wall while dead.".to_string());
    }
    
    if player.is_knocked_out {
        return Err("Cannot place wall while knocked out.".to_string());
    }
    
    // 2. Validate Blueprint equipped
    if !player_has_blueprint(ctx, sender_id) {
        return Err("Blueprint must be equipped to place building pieces.".to_string());
    }
    
    // 3. Validate tier
    if !is_valid_building_tier(tier) {
        return Err(format!("Invalid building tier: {}. Must be 0-3 (Twig, Wood, Stone, Metal).", tier));
    }
    
    let building_tier = match tier {
        0 => BuildingTier::Twig,
        1 => BuildingTier::Wood,
        2 => BuildingTier::Stone,
        3 => BuildingTier::Metal,
        _ => return Err("Invalid building tier".to_string()),
    };
    
    // 4. Convert cell coordinates
    let cell_x_i32 = cell_x as i32;
    let cell_y_i32 = cell_y as i32;
    
    // 5. Get foundation shape FIRST (needed for edge determination)
    let mut foundation_shape = FoundationShape::Full;
    for foundation in foundations.idx_cell_coords().filter((cell_x_i32, cell_y_i32)) {
        if !foundation.is_destroyed {
            foundation_shape = match foundation.shape {
                0 => FoundationShape::Empty,
                1 => FoundationShape::Full,
                2 => FoundationShape::TriNW,
                3 => FoundationShape::TriNE,
                4 => FoundationShape::TriSE,
                5 => FoundationShape::TriSW,
                _ => FoundationShape::Full,
            };
            break;
        }
    }
    
    // 6. Determine edge and facing based on world position, player position, and foundation shape
    let (edge, facing) = determine_wall_edge_and_facing(
        world_x,
        world_y,
        cell_x_i32,
        cell_y_i32,
        player.position_x,
        player.position_y,
        foundation_shape,
    );
    
    // 7. Validate wall position (foundation exists, no overlapping wall)
    is_wall_position_valid(ctx, cell_x_i32, cell_y_i32, edge, facing)?;
    
    // 8. Check placement distance from player
    let tile_center_x = (cell_x_i32 as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
    let tile_center_y = (cell_y_i32 as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
    
    let dx = tile_center_x - player.position_x;
    let dy = tile_center_y - player.position_y;
    let dist_sq = dx * dx + dy * dy;
    
    if dist_sq > BUILDING_PLACEMENT_MAX_DISTANCE_SQUARED {
        return Err(format!(
            "Wall placement too far from player. Distance: {:.1}px, Max: {:.1}px",
            dist_sq.sqrt(),
            BUILDING_PLACEMENT_MAX_DISTANCE
        ));
    }
    
    // 9. Calculate chunk index
    let chunk_index = calculate_chunk_index(tile_center_x, tile_center_y);
    
    // 10. Get max health for this tier
    let max_health = get_wall_max_health(building_tier);
    
    // 11. Check and consume resources (Twig tier uses wood, cost: 15 wood per wall)
    let required_wood = 15;
    
    let inventory = ctx.db.inventory_item();
    let item_defs = ctx.db.item_definition();
    
    // Find "Wood" item definition
    let wood_item_def = item_defs.iter()
        .find(|def| def.name == "Wood")
        .ok_or_else(|| "Wood item definition not found".to_string())?;
    
    // Find wood items in player's inventory OR hotbar
    let mut wood_items: Vec<_> = inventory.iter()
        .filter(|item| {
            let is_owned = match &item.location {
                ItemLocation::Inventory(data) => data.owner_id == sender_id,
                ItemLocation::Hotbar(data) => data.owner_id == sender_id,
                _ => false,
            };
            is_owned &&
            item.item_def_id == wood_item_def.id &&
            item.quantity > 0
        })
        .collect();
    
    // Calculate total wood available
    let total_wood: u32 = wood_items.iter().map(|item| item.quantity).sum();
    
    if total_wood < required_wood {
        return Err(format!(
            "Not enough wood. Required: {}, Available: {}",
            required_wood, total_wood
        ));
    }
    
    // Consume wood
    let mut remaining_to_consume = required_wood;
    for wood_item in &wood_items {
        if remaining_to_consume == 0 {
            break;
        }
        
        let consume_from_this = remaining_to_consume.min(wood_item.quantity);
        let new_quantity = wood_item.quantity - consume_from_this;
        remaining_to_consume -= consume_from_this;
        
        if new_quantity == 0 {
            ctx.db.inventory_item().instance_id().delete(wood_item.instance_id);
        } else {
            let mut updated_item = wood_item.clone();
            updated_item.quantity = new_quantity;
            ctx.db.inventory_item().instance_id().update(updated_item);
        }
    }
    
    log::info!("[PlaceWall] Consumed {} wood from player {:?}", required_wood, sender_id);
    
    // 12. Create and insert wall
    let new_wall = WallCell {
        id: 0, // Auto-incremented
        cell_x: cell_x_i32,
        cell_y: cell_y_i32,
        chunk_index,
        edge: edge as u8,
        facing: facing as u8,
        foundation_shape: foundation_shape as u8,
        tier,
        health: max_health,
        max_health,
        owner: sender_id,
        placed_at: ctx.timestamp,
        is_destroyed: false,
        destroyed_at: None,
        last_hit_time: None,
        last_damaged_by: None,
        group_id: None,
    };
    
    walls.try_insert(new_wall)
        .map_err(|e| format!("Failed to insert wall: {}", e))?;
    
    // 13. Emit foundation construction sound (walls use same sound as foundations)
    crate::sound_events::emit_foundation_wood_constructed_sound(ctx, tile_center_x, tile_center_y, sender_id);
    
    log::info!(
        "[PlaceWall] Successfully placed wall at cell ({}, {}), edge={:?}, facing={:?}, tier={:?}, health={:.1}",
        cell_x, cell_y, edge, facing, building_tier, max_health
    );
    
    Ok(())
}

/// Upgrade a wall to a higher tier
#[spacetimedb::reducer]
pub fn upgrade_wall(
    ctx: &ReducerContext,
    wall_id: u64,
    new_tier: u8,
) -> Result<(), String> {
    let sender_id = ctx.sender;
    let players = ctx.db.player();
    let walls = ctx.db.wall_cell();
    
    log::info!(
        "[UpgradeWall] Player {:?} attempting to upgrade wall {} to tier {}",
        sender_id, wall_id, new_tier
    );
    
    // 1. Validate player
    let player = players.identity().find(&sender_id)
        .ok_or_else(|| "Player not found".to_string())?;
    
    if player.is_dead {
        return Err("Cannot upgrade wall while dead.".to_string());
    }
    
    if player.is_knocked_out {
        return Err("Cannot upgrade wall while knocked out.".to_string());
    }
    
    // 2. Validate Repair Hammer equipped
    if !player_has_repair_hammer(ctx, sender_id) {
        return Err("Repair Hammer must be equipped to upgrade walls.".to_string());
    }
    
    // 3. Find wall
    let wall = walls.id().find(&wall_id)
        .ok_or_else(|| "Wall not found".to_string())?;
    
    if wall.is_destroyed {
        return Err("Cannot upgrade destroyed wall.".to_string());
    }
    
    // 4. Validate new tier
    if !is_valid_building_tier(new_tier) {
        return Err(format!("Invalid building tier: {}. Must be 0-3 (Twig, Wood, Stone, Metal).", new_tier));
    }
    
    let current_tier = match wall.tier {
        0 => BuildingTier::Twig,
        1 => BuildingTier::Wood,
        2 => BuildingTier::Stone,
        3 => BuildingTier::Metal,
        _ => return Err("Invalid current wall tier".to_string()),
    };
    
    let target_tier = match new_tier {
        0 => BuildingTier::Twig,
        1 => BuildingTier::Wood,
        2 => BuildingTier::Stone,
        3 => BuildingTier::Metal,
        _ => return Err("Invalid target tier".to_string()),
    };
    
    // 5. Ensure upgrade is to a higher tier
    if new_tier <= wall.tier {
        return Err(format!("Cannot downgrade wall. Current tier: {}, Target tier: {}", wall.tier, new_tier));
    }
    
    // 6. Check placement distance from player
    let world_x = (wall.cell_x as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
    let world_y = (wall.cell_y as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
    
    let dx = world_x - player.position_x;
    let dy = world_y - player.position_y;
    let dist_sq = dx * dx + dy * dy;
    
    if dist_sq > BUILDING_PLACEMENT_MAX_DISTANCE_SQUARED {
        return Err("Wall is too far away.".to_string());
    }
    
    // 7. Calculate resource costs based on target tier
    let inventory = ctx.db.inventory_item();
    let item_defs = ctx.db.item_definition();
    
    // Wall costs: Wood tier = 20 wood, Stone tier = 20 stone, Metal tier = 20 metal fragments
    let required_wood = if target_tier == BuildingTier::Wood { 20 } else { 0 };
    let required_stone = if target_tier == BuildingTier::Stone { 20 } else { 0 };
    let required_metal = if target_tier == BuildingTier::Metal { 20 } else { 0 };
    
    // Check and consume wood
    if required_wood > 0 {
        let wood_item_def = item_defs.iter()
            .find(|def| def.name == "Wood")
            .ok_or_else(|| "Wood item definition not found".to_string())?;
        
        let mut wood_items: Vec<_> = inventory.iter()
            .filter(|item| {
                let is_owned = match &item.location {
                    ItemLocation::Inventory(data) => data.owner_id == sender_id,
                    ItemLocation::Hotbar(data) => data.owner_id == sender_id,
                    _ => false,
                };
                is_owned &&
                item.item_def_id == wood_item_def.id &&
                item.quantity > 0
            })
            .collect();
        
        let total_wood: u32 = wood_items.iter().map(|item| item.quantity).sum();
        
        if total_wood < required_wood {
            return Err(format!(
                "Not enough wood. Required: {}, Available: {}",
                required_wood, total_wood
            ));
        }
        
        let mut remaining_to_consume = required_wood;
        for wood_item in &wood_items {
            if remaining_to_consume == 0 {
                break;
            }
            
            let consume_from_this = remaining_to_consume.min(wood_item.quantity);
            let new_quantity = wood_item.quantity - consume_from_this;
            remaining_to_consume -= consume_from_this;
            
            if new_quantity == 0 {
                ctx.db.inventory_item().instance_id().delete(wood_item.instance_id);
            } else {
                let mut updated_item = wood_item.clone();
                updated_item.quantity = new_quantity;
                ctx.db.inventory_item().instance_id().update(updated_item);
            }
        }
        
        log::info!("[UpgradeWall] Consumed {} wood from player {:?}", required_wood, sender_id);
    }
    
    // Check and consume stone
    if required_stone > 0 {
        let stone_item_def = item_defs.iter()
            .find(|def| def.name == "Stone")
            .ok_or_else(|| "Stone item definition not found".to_string())?;
        
        let mut stone_items: Vec<_> = inventory.iter()
            .filter(|item| {
                let is_owned = match &item.location {
                    ItemLocation::Inventory(data) => data.owner_id == sender_id,
                    ItemLocation::Hotbar(data) => data.owner_id == sender_id,
                    _ => false,
                };
                is_owned &&
                item.item_def_id == stone_item_def.id &&
                item.quantity > 0
            })
            .collect();
        
        let total_stone: u32 = stone_items.iter().map(|item| item.quantity).sum();
        
        if total_stone < required_stone {
            return Err(format!(
                "Not enough stone. Required: {}, Available: {}",
                required_stone, total_stone
            ));
        }
        
        let mut remaining_to_consume = required_stone;
        for stone_item in &stone_items {
            if remaining_to_consume == 0 {
                break;
            }
            
            let consume_from_this = remaining_to_consume.min(stone_item.quantity);
            let new_quantity = stone_item.quantity - consume_from_this;
            remaining_to_consume -= consume_from_this;
            
            if new_quantity == 0 {
                ctx.db.inventory_item().instance_id().delete(stone_item.instance_id);
            } else {
                let mut updated_item = stone_item.clone();
                updated_item.quantity = new_quantity;
                ctx.db.inventory_item().instance_id().update(updated_item);
            }
        }
        
        log::info!("[UpgradeWall] Consumed {} stone from player {:?}", required_stone, sender_id);
    }
    
    // Check and consume metal fragments
    if required_metal > 0 {
        let metal_item_def = item_defs.iter()
            .find(|def| def.name == "Metal Fragments")
            .ok_or_else(|| "Metal Fragments item definition not found".to_string())?;
        
        let mut metal_items: Vec<_> = inventory.iter()
            .filter(|item| {
                let is_owned = match &item.location {
                    ItemLocation::Inventory(data) => data.owner_id == sender_id,
                    ItemLocation::Hotbar(data) => data.owner_id == sender_id,
                    _ => false,
                };
                is_owned &&
                item.item_def_id == metal_item_def.id &&
                item.quantity > 0
            })
            .collect();
        
        let total_metal: u32 = metal_items.iter().map(|item| item.quantity).sum();
        
        if total_metal < required_metal {
            return Err(format!(
                "Not enough metal fragments. Required: {}, Available: {}",
                required_metal, total_metal
            ));
        }
        
        let mut remaining_to_consume = required_metal;
        for metal_item in &metal_items {
            if remaining_to_consume == 0 {
                break;
            }
            
            let consume_from_this = remaining_to_consume.min(metal_item.quantity);
            let new_quantity = metal_item.quantity - consume_from_this;
            remaining_to_consume -= consume_from_this;
            
            if new_quantity == 0 {
                ctx.db.inventory_item().instance_id().delete(metal_item.instance_id);
            } else {
                let mut updated_item = metal_item.clone();
                updated_item.quantity = new_quantity;
                ctx.db.inventory_item().instance_id().update(updated_item);
            }
        }
        
        log::info!("[UpgradeWall] Consumed {} metal fragments from player {:?}", required_metal, sender_id);
    }
    
    // 8. Update wall tier and health
    let new_max_health = get_wall_max_health(target_tier);
    let health_ratio = wall.health / wall.max_health;
    let new_health = new_max_health * health_ratio; // Preserve health percentage
    
    let mut updated_wall = wall.clone();
    updated_wall.tier = new_tier;
    updated_wall.max_health = new_max_health;
    updated_wall.health = new_health;
    
    walls.id().update(updated_wall);
    
    // 9. Emit upgrade sound based on tier
    match target_tier {
        BuildingTier::Wood => {
            crate::sound_events::emit_foundation_wood_upgraded_sound(ctx, world_x, world_y, sender_id);
        },
        BuildingTier::Stone => {
            crate::sound_events::emit_foundation_stone_upgraded_sound(ctx, world_x, world_y, sender_id);
        },
        BuildingTier::Metal => {
            crate::sound_events::emit_foundation_metal_upgraded_sound(ctx, world_x, world_y, sender_id);
        },
        BuildingTier::Twig => {
            // Should not happen, but handle it
        },
    }
    
    log::info!(
        "[UpgradeWall] Successfully upgraded wall {} from {:?} to {:?}, health={:.1}/{:.1}",
        wall_id, current_tier, target_tier, new_health, new_max_health
    );
    
    Ok(())
}

/// Destroy a twig wall (only twig walls can be destroyed)
#[spacetimedb::reducer]
pub fn destroy_wall(ctx: &ReducerContext, wall_id: u64) -> Result<(), String> {
    use crate::sound_events;
    
    let sender_id = ctx.sender;
    let walls = ctx.db.wall_cell();
    let players = ctx.db.player();
    
    // 1. Validate player exists and is not knocked out
    let player = players.identity().find(&sender_id)
        .ok_or_else(|| "Player not found".to_string())?;
    
    if player.is_knocked_out {
        return Err("Cannot destroy wall while knocked out.".to_string());
    }
    
    // 2. Validate Repair Hammer equipped
    if !player_has_repair_hammer(ctx, sender_id) {
        return Err("Repair Hammer must be equipped to destroy walls.".to_string());
    }
    
    // 3. Find wall
    let wall = walls.id().find(&wall_id)
        .ok_or_else(|| "Wall not found".to_string())?;
    
    if wall.is_destroyed {
        return Err("Wall is already destroyed.".to_string());
    }
    
    // 4. Only twig walls can be destroyed
    if wall.tier != 0 {
        return Err("Only twig walls can be destroyed.".to_string());
    }
    
    // 5. Check placement distance from player
    let world_x = (wall.cell_x as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
    let world_y = (wall.cell_y as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
    
    let dx = world_x - player.position_x;
    let dy = world_y - player.position_y;
    let dist_sq = dx * dx + dy * dy;
    
    if dist_sq > BUILDING_PLACEMENT_MAX_DISTANCE_SQUARED {
        return Err("Wall is too far away.".to_string());
    }
    
    // 6. Mark wall as destroyed
    let mut updated_wall = wall.clone();
    updated_wall.is_destroyed = true;
    updated_wall.destroyed_at = Some(ctx.timestamp);
    
    walls.id().update(updated_wall);
    
    // 7. Emit destroy sound (using foundation destroy sound for now)
    sound_events::emit_foundation_twig_destroyed_sound(ctx, world_x, world_y, sender_id);
    
    log::info!(
        "[DestroyWall] Successfully destroyed twig wall {} at ({}, {})",
        wall_id, wall.cell_x, wall.cell_y
    );
    
    Ok(())
}
