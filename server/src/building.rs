/******************************************************************************
 *                                                                            *
 * Building System - Foundations, Walls, Doors                                *
 *                                                                            *
 * Handles placement, destruction, and management of building pieces.        *
 *                                                                            *
 ******************************************************************************/

use spacetimedb::{Identity, Timestamp, ReducerContext, Table, log};
use crate::{
    models::{FoundationShape, BuildingEdge, BuildingFacing, BuildingTier, TargetType, ItemLocation},
    environment::calculate_chunk_index,
    TILE_SIZE_PX,
    world_pos_to_tile_coords,
};
use crate::player as PlayerTableTrait;
use crate::active_equipment::active_equipment as ActiveEquipmentTableTrait;
use crate::items::{item_definition as ItemDefinitionTableTrait, inventory_item as InventoryItemTableTrait};

// Import table traits
// Table trait will be auto-generated by SpacetimeDB

// --- Constants ---

// Building health constants (per tier)
pub const FOUNDATION_WOOD_MAX_HEALTH: f32 = 500.0;
pub const FOUNDATION_STONE_MAX_HEALTH: f32 = 1000.0;
pub const FOUNDATION_METAL_MAX_HEALTH: f32 = 2000.0;

pub const WALL_WOOD_MAX_HEALTH: f32 = 250.0;
pub const WALL_STONE_MAX_HEALTH: f32 = 500.0;
pub const WALL_METAL_MAX_HEALTH: f32 = 1000.0;

pub const DOORFRAME_WOOD_MAX_HEALTH: f32 = 200.0;
pub const DOORFRAME_STONE_MAX_HEALTH: f32 = 400.0;
pub const DOORFRAME_METAL_MAX_HEALTH: f32 = 800.0;

pub const DOOR_WOOD_MAX_HEALTH: f32 = 150.0;
pub const DOOR_STONE_MAX_HEALTH: f32 = 300.0;
pub const DOOR_METAL_MAX_HEALTH: f32 = 600.0;

// Placement distance
pub const BUILDING_PLACEMENT_MAX_DISTANCE: f32 = 128.0;
pub const BUILDING_PLACEMENT_MAX_DISTANCE_SQUARED: f32 = BUILDING_PLACEMENT_MAX_DISTANCE * BUILDING_PLACEMENT_MAX_DISTANCE;

// --- Foundation Cell Table ---
#[spacetimedb::table(
    name = foundation_cell,
    public,
    index(name = idx_chunk, btree(columns = [chunk_index])),
    index(name = idx_cell_coords, btree(columns = [cell_x, cell_y]))
)]
#[derive(Clone, Debug)]
pub struct FoundationCell {
    #[primary_key]
    #[auto_inc]
    pub id: u64,
    pub cell_x: i32,  // Tile X coordinate (1:1 mapping with tiles)
    pub cell_y: i32,  // Tile Y coordinate
    pub chunk_index: u32,  // For chunk-based spatial subscriptions
    pub shape: u8,    // FoundationShape enum (0-5)
    pub tier: u8,     // BuildingTier enum (0-2: Wood, Stone, Metal)
    pub health: f32,
    pub max_health: f32,
    pub owner: Identity,
    pub placed_at: Timestamp,
    pub is_destroyed: bool,
    pub destroyed_at: Option<Timestamp>,
    pub last_hit_time: Option<Timestamp>,
    pub last_damaged_by: Option<Identity>,
    pub group_id: Option<i64>,  // For future building groups/clans
}

// --- Helper Functions ---

/// Check if player has Blueprint equipped
pub fn player_has_blueprint(ctx: &ReducerContext, player_id: Identity) -> bool {
    let active_equipments = ctx.db.active_equipment();
    let item_defs = ctx.db.item_definition();
    
    if let Some(equipment) = active_equipments.player_identity().find(&player_id) {
        if let Some(item_def_id) = equipment.equipped_item_def_id {
            if let Some(item_def) = item_defs.id().find(&item_def_id) {
                return item_def.name == "Blueprint";
            }
        }
    }
    
    false
}

/// Get foundation max health based on tier
pub fn get_foundation_max_health(tier: BuildingTier) -> f32 {
    match tier {
        BuildingTier::Wood => FOUNDATION_WOOD_MAX_HEALTH,
        BuildingTier::Stone => FOUNDATION_STONE_MAX_HEALTH,
        BuildingTier::Metal => FOUNDATION_METAL_MAX_HEALTH,
    }
}

/// Validate foundation shape enum value
pub fn is_valid_foundation_shape(shape: u8) -> bool {
    matches!(shape, 0..=5) // Empty, Full, TriNW, TriNE, TriSE, TriSW
}

/// Validate building tier enum value
pub fn is_valid_building_tier(tier: u8) -> bool {
    matches!(tier, 0..=2) // Wood, Stone, Metal
}

/// Check if a foundation cell position is valid (not overlapping with existing foundation)
pub fn is_foundation_position_valid(
    ctx: &ReducerContext,
    cell_x: i32,
    cell_y: i32,
    shape: FoundationShape,
) -> bool {
    let foundations = ctx.db.foundation_cell();
    
    // Check if there's already a foundation at this cell
    for foundation in foundations.idx_cell_coords().filter((cell_x, cell_y)) {
        // If there's an existing foundation and it's not destroyed
        if !foundation.is_destroyed {
            // Convert stored u8 shape to FoundationShape enum for comparison
            let existing_shape = match foundation.shape {
                0 => FoundationShape::Empty,
                1 => FoundationShape::Full,
                2 => FoundationShape::TriNW,
                3 => FoundationShape::TriNE,
                4 => FoundationShape::TriSE,
                5 => FoundationShape::TriSW,
                _ => continue, // Invalid shape, skip
            };
            
            // Check if shapes are compatible (triangles can merge into Full)
            match (shape, existing_shape) {
                (FoundationShape::Full, FoundationShape::Full) => return false, // Overlap
                (FoundationShape::TriNW, FoundationShape::TriNW) => return false, // Overlap
                (FoundationShape::TriNE, FoundationShape::TriNE) => return false, // Overlap
                (FoundationShape::TriSE, FoundationShape::TriSE) => return false, // Overlap
                (FoundationShape::TriSW, FoundationShape::TriSW) => return false, // Overlap
                // Triangles can merge into Full - this will be handled in placement logic
                _ => return false, // Different shapes overlap
            }
        }
    }
    
    true
}

// --- Reducers ---

/// Place a foundation cell at the specified tile coordinates
#[spacetimedb::reducer]
pub fn place_foundation(
    ctx: &ReducerContext,
    cell_x: i64,
    cell_y: i64,
    shape: u8,
    tier: u8,
) -> Result<(), String> {
    let sender_id = ctx.sender;
    let players = ctx.db.player();
    let foundations = ctx.db.foundation_cell();
    
    log::info!(
        "[PlaceFoundation] Player {:?} attempting to place foundation at cell ({}, {}), shape={}, tier={}",
        sender_id, cell_x, cell_y, shape, tier
    );
    
    // 1. Validate player
    let player = players.identity().find(&sender_id)
        .ok_or_else(|| "Player not found".to_string())?;
    
    if player.is_dead {
        return Err("Cannot place foundation while dead.".to_string());
    }
    
    if player.is_knocked_out {
        return Err("Cannot place foundation while knocked out.".to_string());
    }
    
    // 2. Validate Blueprint equipped
    if !player_has_blueprint(ctx, sender_id) {
        return Err("Blueprint must be equipped to place building pieces.".to_string());
    }
    
    // 3. Validate shape and tier enum values
    if !is_valid_foundation_shape(shape) {
        return Err(format!("Invalid foundation shape: {}. Must be 0-5.", shape));
    }
    
    if !is_valid_building_tier(tier) {
        return Err(format!("Invalid building tier: {}. Must be 0-2 (Wood, Stone, Metal).", tier));
    }
    
    let foundation_shape = match shape {
        0 => FoundationShape::Empty,
        1 => FoundationShape::Full,
        2 => FoundationShape::TriNW,
        3 => FoundationShape::TriNE,
        4 => FoundationShape::TriSE,
        5 => FoundationShape::TriSW,
        _ => return Err("Invalid foundation shape".to_string()),
    };
    
    let building_tier = match tier {
        0 => BuildingTier::Wood,
        1 => BuildingTier::Stone,
        2 => BuildingTier::Metal,
        _ => return Err("Invalid building tier".to_string()),
    };
    
    // 4. Validate position (check for overlaps)
    let cell_x_i32 = cell_x as i32;
    let cell_y_i32 = cell_y as i32;
    if !is_foundation_position_valid(ctx, cell_x_i32, cell_y_i32, foundation_shape) {
        return Err(format!("Cannot place foundation at ({}, {}): position already occupied or invalid.", cell_x, cell_y));
    }
    
    // 5. Check placement distance from player
    // Convert cell coordinates to world pixel coordinates (center of tile)
    let world_x = (cell_x_i32 as f32 * TILE_SIZE_PX as f32) + (TILE_SIZE_PX as f32 / 2.0);
    let world_y = (cell_y_i32 as f32 * TILE_SIZE_PX as f32) + (TILE_SIZE_PX as f32 / 2.0);
    
    let dx = world_x - player.position_x;
    let dy = world_y - player.position_y;
    let dist_sq = dx * dx + dy * dy;
    
    if dist_sq > BUILDING_PLACEMENT_MAX_DISTANCE_SQUARED {
        return Err(format!(
            "Foundation placement too far from player. Distance: {:.1}px, Max: {:.1}px",
            dist_sq.sqrt(),
            BUILDING_PLACEMENT_MAX_DISTANCE
        ));
    }
    
    // 6. Calculate chunk index
    let chunk_index = calculate_chunk_index(world_x, world_y);
    
    // 7. Get max health for this tier
    let max_health = get_foundation_max_health(building_tier);
    
    // 8. Check and consume wood (cost depends on shape: 50 for full, 25 for triangles)
    let required_wood = match foundation_shape {
        FoundationShape::Full => 50,
        FoundationShape::TriNW | FoundationShape::TriNE | FoundationShape::TriSE | FoundationShape::TriSW => 25,
        _ => 50, // Default to 50 for unknown shapes
    };
    
    let inventory = ctx.db.inventory_item();
    let item_defs = ctx.db.item_definition();
    
    // Find "Wood" item definition
    let wood_item_def = item_defs.iter()
        .find(|def| def.name == "Wood")
        .ok_or_else(|| "Wood item definition not found".to_string())?;
    
    // Find wood items in player's inventory OR hotbar
    let mut wood_items: Vec<_> = inventory.iter()
        .filter(|item| {
            let is_owned = match &item.location {
                ItemLocation::Inventory(data) => data.owner_id == sender_id,
                ItemLocation::Hotbar(data) => data.owner_id == sender_id,
                _ => false,
            };
            is_owned &&
            item.item_def_id == wood_item_def.id &&
            item.quantity > 0
        })
        .collect();
    
    // Calculate total wood available
    let total_wood: u32 = wood_items.iter().map(|item| item.quantity).sum();
    
    if total_wood < required_wood {
        return Err(format!(
            "Not enough wood. Required: {}, Available: {}",
            required_wood, total_wood
        ));
    }
    
    // Consume wood (remove from inventory, starting with first item)
    let mut remaining_to_consume = required_wood;
    for wood_item in &wood_items {
        if remaining_to_consume == 0 {
            break;
        }
        
        let consume_from_this = remaining_to_consume.min(wood_item.quantity);
        let new_quantity = wood_item.quantity - consume_from_this;
        remaining_to_consume -= consume_from_this;
        
        if new_quantity == 0 {
            // Delete item if quantity reaches 0
            ctx.db.inventory_item().instance_id().delete(wood_item.instance_id);
        } else {
            // Update item with new quantity
            let mut updated_item = wood_item.clone();
            updated_item.quantity = new_quantity;
            ctx.db.inventory_item().instance_id().update(updated_item);
        }
    }
    
    log::info!("[PlaceFoundation] Consumed {} wood from player {:?}", required_wood, sender_id);
    
    // 9. Create and insert foundation
    let new_foundation = FoundationCell {
        id: 0, // Auto-incremented
        cell_x: cell_x_i32,
        cell_y: cell_y_i32,
        chunk_index,
        shape,
        tier,
        health: max_health,
        max_health,
        owner: sender_id,
        placed_at: ctx.timestamp,
        is_destroyed: false,
        destroyed_at: None,
        last_hit_time: None,
        last_damaged_by: None,
        group_id: None, // TODO: Implement group system
    };
    
    foundations.try_insert(new_foundation)
        .map_err(|e| format!("Failed to insert foundation: {}", e))?;
    
    // 10. Emit foundation construction sound for all nearby players
    crate::sound_events::emit_foundation_wood_constructed_sound(ctx, world_x, world_y, sender_id);
    
    log::info!(
        "[PlaceFoundation] Successfully placed foundation at cell ({}, {}), tier={:?}, health={:.1}",
        cell_x, cell_y, building_tier, max_health
    );
    
    Ok(())
}

