/******************************************************************************
 *                                                                            *
 * Building System - Foundations, Walls, Doors                                *
 *                                                                            *
 * Handles placement, destruction, and management of building pieces.        *
 *                                                                            *
 ******************************************************************************/

use spacetimedb::{Identity, Timestamp, ReducerContext, Table, log};
use crate::{
    models::{FoundationShape, BuildingEdge, BuildingFacing, BuildingTier, TargetType, ItemLocation},
    environment::{calculate_chunk_index, is_position_on_water},
    TILE_SIZE_PX,
    world_pos_to_tile_coords,
};
use crate::player as PlayerTableTrait;
use crate::active_equipment::active_equipment as ActiveEquipmentTableTrait;
use crate::items::{item_definition as ItemDefinitionTableTrait, inventory_item as InventoryItemTableTrait};
use crate::homestead_hearth::homestead_hearth as HomesteadHearthTableTrait;
use crate::rune_stone::{rune_stone as RuneStoneTableTrait, RUNE_STONE_LIGHT_RADIUS};

// Import table traits
// Table trait will be auto-generated by SpacetimeDB

// --- Constants ---

// Building health constants (per tier)
// Twig tier: Easy to break with Combat Ladle (10 dmg/hit) - ~5-8 hits for foundations
pub const FOUNDATION_TWIG_MAX_HEALTH: f32 = 75.0;   // ~8 hits with Combat Ladle
pub const FOUNDATION_WOOD_MAX_HEALTH: f32 = 500.0; // ~50 hits (2x old Wood)
pub const FOUNDATION_STONE_MAX_HEALTH: f32 = 1000.0; // ~100 hits
pub const FOUNDATION_METAL_MAX_HEALTH: f32 = 2000.0; // ~200 hits

// Walls: Thinner than foundations, easier to break
pub const WALL_TWIG_MAX_HEALTH: f32 = 50.0;   // ~5 hits with Combat Ladle
pub const WALL_WOOD_MAX_HEALTH: f32 = 250.0;  // ~25 hits
pub const WALL_STONE_MAX_HEALTH: f32 = 500.0; // ~50 hits
pub const WALL_METAL_MAX_HEALTH: f32 = 1000.0; // ~100 hits

// Doors: Weakest building piece, easiest to break
pub const DOOR_TWIG_MAX_HEALTH: f32 = 30.0;  // ~3 hits with Combat Ladle
pub const DOOR_WOOD_MAX_HEALTH: f32 = 150.0; // ~15 hits
pub const DOOR_STONE_MAX_HEALTH: f32 = 300.0; // ~30 hits
pub const DOOR_METAL_MAX_HEALTH: f32 = 600.0; // ~60 hits

// Placement distance
pub const BUILDING_PLACEMENT_MAX_DISTANCE: f32 = 128.0;
pub const BUILDING_PLACEMENT_MAX_DISTANCE_SQUARED: f32 = BUILDING_PLACEMENT_MAX_DISTANCE * BUILDING_PLACEMENT_MAX_DISTANCE;

// Foundation grid is 2x world tiles (96px) for larger building pieces
pub const FOUNDATION_TILE_SIZE_PX: u32 = 96; // 2x TILE_SIZE_PX

// --- Foundation Cell Table ---
#[spacetimedb::table(
    name = foundation_cell,
    public,
    index(name = idx_chunk, btree(columns = [chunk_index])),
    index(name = idx_cell_coords, btree(columns = [cell_x, cell_y]))
)]
#[derive(Clone, Debug)]
pub struct FoundationCell {
    #[primary_key]
    #[auto_inc]
    pub id: u64,
    pub cell_x: i32,  // Foundation cell X coordinate (96px grid, 2x world tiles)
    pub cell_y: i32,  // Foundation cell Y coordinate (96px grid, 2x world tiles)
    pub chunk_index: u32,  // For chunk-based spatial subscriptions
    pub shape: u8,    // FoundationShape enum (0-5)
    pub tier: u8,     // BuildingTier enum (0-3: Twig, Wood, Stone, Metal)
    pub health: f32,
    pub max_health: f32,
    pub owner: Identity,
    pub placed_at: Timestamp,
    pub is_destroyed: bool,
    pub destroyed_at: Option<Timestamp>,
    pub last_hit_time: Option<Timestamp>,
    pub last_damaged_by: Option<Identity>,
    pub group_id: Option<i64>,  // For future building groups/clans
}

// --- Wall Cell Table ---
#[spacetimedb::table(
    name = wall_cell,
    public,
    index(name = idx_chunk, btree(columns = [chunk_index])),
    index(name = idx_cell_coords, btree(columns = [cell_x, cell_y]))
)]
#[derive(Clone, Debug)]
pub struct WallCell {
    #[primary_key]
    #[auto_inc]
    pub id: u64,
    pub cell_x: i32,  // Foundation cell X coordinate (wall is on edge of this foundation cell)
    pub cell_y: i32,  // Foundation cell Y coordinate (96px grid, 2x world tiles)
    pub chunk_index: u32,  // For chunk-based spatial subscriptions
    pub edge: u8,     // BuildingEdge enum (0-3: N, E, S, W)
    pub facing: u8,   // BuildingFacing enum (0: Interior, 1: Exterior)
    pub foundation_shape: u8,  // FoundationShape enum (0-5) - which foundation this wall is on
    pub tier: u8,     // BuildingTier enum (0-3: Twig, Wood, Stone, Metal)
    pub health: f32,
    pub max_health: f32,
    pub owner: Identity,
    pub placed_at: Timestamp,
    pub is_destroyed: bool,
    pub destroyed_at: Option<Timestamp>,
    pub last_hit_time: Option<Timestamp>,
    pub last_damaged_by: Option<Identity>,
    pub group_id: Option<i64>,  // For future building groups/clans
}

// --- Helper Functions ---

/// Check if player has Blueprint equipped
pub fn player_has_blueprint(ctx: &ReducerContext, player_id: Identity) -> bool {
    let active_equipments = ctx.db.active_equipment();
    let item_defs = ctx.db.item_definition();
    
    if let Some(equipment) = active_equipments.player_identity().find(&player_id) {
        if let Some(item_def_id) = equipment.equipped_item_def_id {
            if let Some(item_def) = item_defs.id().find(&item_def_id) {
                return item_def.name == "Blueprint";
            }
        }
    }
    
    false
}

/// Check if player has Repair Hammer equipped
pub fn player_has_repair_hammer(ctx: &ReducerContext, player_id: Identity) -> bool {
    let active_equipments = ctx.db.active_equipment();
    let item_defs = ctx.db.item_definition();
    
    if let Some(equipment) = active_equipments.player_identity().find(&player_id) {
        if let Some(item_def_id) = equipment.equipped_item_def_id {
            if let Some(item_def) = item_defs.id().find(&item_def_id) {
                return item_def.name == "Repair Hammer";
            }
        }
    }
    
    false
}

/// Get foundation max health based on tier
pub fn get_foundation_max_health(tier: BuildingTier) -> f32 {
    match tier {
        BuildingTier::Twig => FOUNDATION_TWIG_MAX_HEALTH,
        BuildingTier::Wood => FOUNDATION_WOOD_MAX_HEALTH,
        BuildingTier::Stone => FOUNDATION_STONE_MAX_HEALTH,
        BuildingTier::Metal => FOUNDATION_METAL_MAX_HEALTH,
    }
}

/// Get wall max health based on tier
pub fn get_wall_max_health(tier: BuildingTier) -> f32 {
    match tier {
        BuildingTier::Twig => WALL_TWIG_MAX_HEALTH,
        BuildingTier::Wood => WALL_WOOD_MAX_HEALTH,
        BuildingTier::Stone => WALL_STONE_MAX_HEALTH,
        BuildingTier::Metal => WALL_METAL_MAX_HEALTH,
    }
}

/// Get door max health based on tier
pub fn get_door_max_health(tier: BuildingTier) -> f32 {
    match tier {
        BuildingTier::Twig => DOOR_TWIG_MAX_HEALTH,
        BuildingTier::Wood => DOOR_WOOD_MAX_HEALTH,
        BuildingTier::Stone => DOOR_STONE_MAX_HEALTH,
        BuildingTier::Metal => DOOR_METAL_MAX_HEALTH,
    }
}

/// Validate foundation shape enum value
pub fn is_valid_foundation_shape(shape: u8) -> bool {
    matches!(shape, 0..=5) // Empty, Full, TriNW, TriNE, TriSE, TriSW
}

/// Validate building tier enum value
pub fn is_valid_building_tier(tier: u8) -> bool {
    matches!(tier, 0..=3) // Twig, Wood, Stone, Metal
}

/// Validate building edge enum value
pub fn is_valid_building_edge(edge: u8) -> bool {
    matches!(edge, 0..=3) // N, E, S, W (diagonals not used for walls)
}

/// Validate building facing enum value
pub fn is_valid_building_facing(facing: u8) -> bool {
    matches!(facing, 0..=1) // Interior, Exterior
}

/// Determine which edge a wall should be placed on based on mouse position relative to tile center
/// Returns (edge, facing) where edge is BuildingEdge and facing is BuildingFacing
/// For triangle foundations, also considers diagonal edges
pub fn determine_wall_edge_and_facing(
    world_x: f32,
    world_y: f32,
    cell_x: i32,
    cell_y: i32,
    player_x: f32,
    player_y: f32,
    foundation_shape: FoundationShape,
) -> (BuildingEdge, BuildingFacing) {
    // Calculate foundation cell center (96px grid)
    let tile_center_x = (cell_x as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
    let tile_center_y = (cell_y as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
    
    // Calculate offset from tile center
    let dx = world_x - tile_center_x;
    let dy = world_y - tile_center_y;
    
    // Determine which edge is closest (snap to nearest edge)
    let abs_dx = dx.abs();
    let abs_dy = dy.abs();
    
    // For triangle foundations, also consider diagonal edges
    let is_triangle = matches!(foundation_shape, FoundationShape::TriNW | FoundationShape::TriNE | FoundationShape::TriSE | FoundationShape::TriSW);
    
    let (edge, facing) = if is_triangle {
        // Calculate distance to diagonal edges
        let diag_nw_se_dist = (dx - dy).abs(); // Distance to NW-SE diagonal
        let diag_ne_sw_dist = (dx + dy).abs(); // Distance to NE-SW diagonal
        
        // Check if we're closer to a diagonal than to cardinal edges
        let min_cardinal_dist = abs_dx.min(abs_dy);
        let min_diag_dist = diag_nw_se_dist.min(diag_ne_sw_dist);
        
        if min_diag_dist < min_cardinal_dist {
            // Closer to diagonal
            if diag_nw_se_dist < diag_ne_sw_dist {
                // DiagNW_SE (edge 5)
                let facing = if player_x < tile_center_x && player_y < tile_center_y {
                    BuildingFacing::Interior
                } else {
                    BuildingFacing::Exterior
                };
                (BuildingEdge::DiagNW_SE, facing)
            } else {
                // DiagNE_SW (edge 4)
                let facing = if player_x > tile_center_x && player_y < tile_center_y {
                    BuildingFacing::Interior
                } else {
                    BuildingFacing::Exterior
                };
                (BuildingEdge::DiagNE_SW, facing)
            }
        } else {
            // Closer to cardinal edge
            if abs_dy > abs_dx {
                if dy < 0.0 {
                    let facing = if player_y < tile_center_y {
                        BuildingFacing::Interior
                    } else {
                        BuildingFacing::Exterior
                    };
                    (BuildingEdge::N, facing)
                } else {
                    let facing = if player_y > tile_center_y {
                        BuildingFacing::Interior
                    } else {
                        BuildingFacing::Exterior
                    };
                    (BuildingEdge::S, facing)
                }
            } else {
                if dx < 0.0 {
                    let facing = if player_x < tile_center_x {
                        BuildingFacing::Interior
                    } else {
                        BuildingFacing::Exterior
                    };
                    (BuildingEdge::W, facing)
                } else {
                    let facing = if player_x > tile_center_x {
                        BuildingFacing::Interior
                    } else {
                        BuildingFacing::Exterior
                    };
                    (BuildingEdge::E, facing)
                }
            }
        }
    } else {
        // Full foundation - only cardinal edges
        if abs_dy > abs_dx {
            if dy < 0.0 {
                let facing = if player_y < tile_center_y {
                    BuildingFacing::Interior
                } else {
                    BuildingFacing::Exterior
                };
                (BuildingEdge::N, facing)
            } else {
                let facing = if player_y > tile_center_y {
                    BuildingFacing::Interior
                } else {
                    BuildingFacing::Exterior
                };
                (BuildingEdge::S, facing)
            }
        } else {
            if dx < 0.0 {
                let facing = if player_x < tile_center_x {
                    BuildingFacing::Interior
                } else {
                    BuildingFacing::Exterior
                };
                (BuildingEdge::W, facing)
            } else {
                let facing = if player_x > tile_center_x {
                    BuildingFacing::Interior
                } else {
                    BuildingFacing::Exterior
                };
                (BuildingEdge::E, facing)
            }
        }
    };
    
    (edge, facing)
}

/// Check if a wall position is valid (foundation exists, no overlapping wall)
pub fn is_wall_position_valid(
    ctx: &ReducerContext,
    cell_x: i32,
    cell_y: i32,
    edge: BuildingEdge,
    facing: BuildingFacing,
) -> Result<(), String> {
    // 1. Check if there's a foundation at this cell
    let foundations = ctx.db.foundation_cell();
    let mut foundation_found = false;
    let mut foundation_shape = FoundationShape::Full;
    
    for foundation in foundations.idx_cell_coords().filter((cell_x, cell_y)) {
        if !foundation.is_destroyed {
            foundation_found = true;
            foundation_shape = match foundation.shape {
                0 => FoundationShape::Empty,
                1 => FoundationShape::Full,
                2 => FoundationShape::TriNW,
                3 => FoundationShape::TriNE,
                4 => FoundationShape::TriSE,
                5 => FoundationShape::TriSW,
                _ => continue,
            };
            break;
        }
    }
    
    if !foundation_found {
        return Err("Cannot place wall: no foundation at this location.".to_string());
    }
    
    // 2. For triangle foundations, check if the edge is valid
    match foundation_shape {
        FoundationShape::TriNW => {
            // Valid edges: N, W, DiagNW_SE
            if !matches!(edge, BuildingEdge::N | BuildingEdge::W | BuildingEdge::DiagNW_SE) {
                return Err("Invalid edge for triangle foundation (TriNW).".to_string());
            }
        }
        FoundationShape::TriNE => {
            // Valid edges: N, E, DiagNE_SW
            if !matches!(edge, BuildingEdge::N | BuildingEdge::E | BuildingEdge::DiagNE_SW) {
                return Err("Invalid edge for triangle foundation (TriNE).".to_string());
            }
        }
        FoundationShape::TriSE => {
            // Valid edges: S, E, DiagNW_SE
            if !matches!(edge, BuildingEdge::S | BuildingEdge::E | BuildingEdge::DiagNW_SE) {
                return Err("Invalid edge for triangle foundation (TriSE).".to_string());
            }
        }
        FoundationShape::TriSW => {
            // Valid edges: S, W, DiagNE_SW
            if !matches!(edge, BuildingEdge::S | BuildingEdge::W | BuildingEdge::DiagNE_SW) {
                return Err("Invalid edge for triangle foundation (TriSW).".to_string());
            }
        }
        _ => {
            // Full foundation - all edges valid
        }
    }
    
    // 3. Check if there's already a wall at this edge/facing combination
    // Also check adjacent tiles for shared edges
    let walls = ctx.db.wall_cell();
    
    // Check current cell - don't check facing, just edge (walls on same edge block regardless of facing)
    for wall in walls.idx_cell_coords().filter((cell_x, cell_y)) {
        if !wall.is_destroyed && wall.edge == edge as u8 {
            return Err("A wall already exists at this edge.".to_string());
        }
    }
    
    // Check adjacent tiles for shared edges
    // North edge of (x, y) = South edge of (x, y-1)
    // East edge of (x, y) = West edge of (x+1, y)
    // South edge of (x, y) = North edge of (x, y+1)
    // West edge of (x, y) = East edge of (x-1, y)
    let (adjacent_cell_x, adjacent_cell_y, opposite_edge) = match edge {
        BuildingEdge::N => (cell_x, cell_y - 1, BuildingEdge::S as u8),
        BuildingEdge::E => (cell_x + 1, cell_y, BuildingEdge::W as u8),
        BuildingEdge::S => (cell_x, cell_y + 1, BuildingEdge::N as u8),
        BuildingEdge::W => (cell_x - 1, cell_y, BuildingEdge::E as u8),
        _ => {
            // Diagonal edges don't have adjacent tiles (they're internal to the triangle)
            return Ok(());
        }
    };
    
    // Check adjacent cell for a wall on the opposite edge (any facing - shared edge is shared)
    for wall in walls.idx_cell_coords().filter((adjacent_cell_x, adjacent_cell_y)) {
        if !wall.is_destroyed && wall.edge == opposite_edge {
            return Err("A wall already exists on the shared edge with the adjacent tile.".to_string());
        }
    }
    
    Ok(())
}

/// Check if a foundation cell position is valid (not overlapping with existing foundation)
pub fn is_foundation_position_valid(
    ctx: &ReducerContext,
    cell_x: i32,
    cell_y: i32,
    shape: FoundationShape,
) -> bool {
    let foundations = ctx.db.foundation_cell();
    
    // IMPORTANT: Check ALL foundations at this cell - there might be two complementary triangles already
    let mut found_complementary = false;
    let mut found_overlap = false;
    let mut foundation_count = 0;
    
    // Check if there's already a foundation at this cell
    for foundation in foundations.idx_cell_coords().filter((cell_x, cell_y)) {
        // If there's an existing foundation and it's not destroyed
        if !foundation.is_destroyed {
            foundation_count += 1;
            
            // Convert stored u8 shape to FoundationShape enum for comparison
            let existing_shape = match foundation.shape {
                0 => FoundationShape::Empty,
                1 => FoundationShape::Full,
                2 => FoundationShape::TriNW,
                3 => FoundationShape::TriNE,
                4 => FoundationShape::TriSE,
                5 => FoundationShape::TriSW,
                _ => continue, // Invalid shape, skip
            };
            
            // Check if shapes are compatible (triangles can merge into Full)
            match (shape, existing_shape) {
                (FoundationShape::Full, FoundationShape::Full) => return false, // Overlap
                (FoundationShape::TriNW, FoundationShape::TriNW) => return false, // Overlap
                (FoundationShape::TriNE, FoundationShape::TriNE) => return false, // Overlap
                (FoundationShape::TriSE, FoundationShape::TriSE) => return false, // Overlap
                (FoundationShape::TriSW, FoundationShape::TriSW) => return false, // Overlap
                // Complementary triangles can be placed together to form a full square
                (FoundationShape::TriNW, FoundationShape::TriSE) => found_complementary = true, // Compatible
                (FoundationShape::TriSE, FoundationShape::TriNW) => found_complementary = true, // Compatible
                (FoundationShape::TriNE, FoundationShape::TriSW) => found_complementary = true, // Compatible
                (FoundationShape::TriSW, FoundationShape::TriNE) => found_complementary = true, // Compatible
                // Full foundation overlaps with any triangle
                (FoundationShape::Full, _) => return false, // Full overlaps with anything
                (_, FoundationShape::Full) => return false, // Full overlaps with anything
                // Non-complementary triangles overlap
                _ => found_overlap = true, // Different shapes overlap
            }
        }
    }
    
    // If we found an overlap, block placement
    if found_overlap {
        return false;
    }
    
    // If there are already 2 foundations at this cell (two complementary triangles forming a full square),
    // block any further placement
    if foundation_count >= 2 {
        return false; // Already have two triangles forming a full square
    }
    
    // If we found a complementary triangle and no overlaps, allow placement
    // (This handles the case where we're adding the second triangle to form a full square)
    // If no foundations found at all, allow placement
    true
}

// --- Reducers ---

/// Place a foundation cell at the specified tile coordinates
#[spacetimedb::reducer]
pub fn place_foundation(
    ctx: &ReducerContext,
    cell_x: i64,
    cell_y: i64,
    shape: u8,
    tier: u8,
) -> Result<(), String> {
    let sender_id = ctx.sender;
    let players = ctx.db.player();
    let foundations = ctx.db.foundation_cell();
    
    log::info!(
        "[PlaceFoundation] Player {:?} attempting to place foundation at cell ({}, {}), shape={}, tier={}",
        sender_id, cell_x, cell_y, shape, tier
    );
    
    // 1. Validate player
    let player = players.identity().find(&sender_id)
        .ok_or_else(|| "Player not found".to_string())?;
    
    if player.is_dead {
        return Err("Cannot place foundation while dead.".to_string());
    }
    
    if player.is_knocked_out {
        return Err("Cannot place foundation while knocked out.".to_string());
    }
    
    // 2. Validate Blueprint equipped
    if !player_has_blueprint(ctx, sender_id) {
        return Err("Blueprint must be equipped to place building pieces.".to_string());
    }
    
    // 3. Validate shape and tier enum values
    if !is_valid_foundation_shape(shape) {
        return Err(format!("Invalid foundation shape: {}. Must be 0-5.", shape));
    }
    
    if !is_valid_building_tier(tier) {
        return Err(format!("Invalid building tier: {}. Must be 0-3 (Twig, Wood, Stone, Metal).", tier));
    }
    
    let foundation_shape = match shape {
        0 => FoundationShape::Empty,
        1 => FoundationShape::Full,
        2 => FoundationShape::TriNW,
        3 => FoundationShape::TriNE,
        4 => FoundationShape::TriSE,
        5 => FoundationShape::TriSW,
        _ => return Err("Invalid foundation shape".to_string()),
    };
    
    let building_tier = match tier {
        0 => BuildingTier::Twig,
        1 => BuildingTier::Wood,
        2 => BuildingTier::Stone,
        3 => BuildingTier::Metal,
        _ => return Err("Invalid building tier".to_string()),
    };
    
    // 4. Validate position (check for overlaps)
    let cell_x_i32 = cell_x as i32;
    let cell_y_i32 = cell_y as i32;
    if !is_foundation_position_valid(ctx, cell_x_i32, cell_y_i32, foundation_shape) {
        return Err(format!("Cannot place foundation at ({}, {}): position already occupied or invalid.", cell_x, cell_y));
    }
    
    // 5. Check if position is on water (foundations cannot be placed on water tiles)
    // Convert foundation cell coordinates to world pixel coordinates (center of foundation cell)
    let world_x = (cell_x_i32 as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
    let world_y = (cell_y_i32 as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
    
    if is_position_on_water(ctx, world_x, world_y) {
        return Err("Cannot place foundation on water tiles.".to_string());
    }
    
    // 5.5. Check if position is within rune stone light radius (foundations cannot be placed in monument light areas)
    // Use double the light radius (800px) for foundation placement restriction
    let rune_stones = ctx.db.rune_stone();
    let foundation_restriction_radius = RUNE_STONE_LIGHT_RADIUS * 2.0; // 800px - double the light radius
    let foundation_restriction_radius_sq = foundation_restriction_radius * foundation_restriction_radius;
    for rune_stone in rune_stones.iter() {
        let dx = world_x - rune_stone.pos_x;
        let dy = world_y - rune_stone.pos_y;
        let distance_sq = dx * dx + dy * dy;
        
        if distance_sq <= foundation_restriction_radius_sq {
            return Err("Cannot place foundation within a rune stone's light area. These monuments must remain unobstructed.".to_string());
        }
    }
    
    // 6. Check placement distance from player
    let dx = world_x - player.position_x;
    let dy = world_y - player.position_y;
    let dist_sq = dx * dx + dy * dy;
    
    if dist_sq > BUILDING_PLACEMENT_MAX_DISTANCE_SQUARED {
        return Err(format!(
            "Foundation placement too far from player. Distance: {:.1}px, Max: {:.1}px",
            dist_sq.sqrt(),
            BUILDING_PLACEMENT_MAX_DISTANCE
        ));
    }
    
    // 7. Calculate chunk index
    let chunk_index = calculate_chunk_index(world_x, world_y);
    
    // 8. Get max health for this tier
    let max_health = get_foundation_max_health(building_tier);
    
    // 9. Check and consume resources (Twig tier uses wood, cost depends on shape: 50 for full, 25 for triangles)
    let required_wood = match foundation_shape {
        FoundationShape::Full => 50,
        FoundationShape::TriNW | FoundationShape::TriNE | FoundationShape::TriSE | FoundationShape::TriSW => 25,
        _ => 50, // Default to 50 for unknown shapes
    };
    
    let inventory = ctx.db.inventory_item();
    let item_defs = ctx.db.item_definition();
    
    // Find "Wood" item definition
    let wood_item_def = item_defs.iter()
        .find(|def| def.name == "Wood")
        .ok_or_else(|| "Wood item definition not found".to_string())?;
    
    // Find wood items in player's inventory OR hotbar
    let mut wood_items: Vec<_> = inventory.iter()
        .filter(|item| {
            let is_owned = match &item.location {
                ItemLocation::Inventory(data) => data.owner_id == sender_id,
                ItemLocation::Hotbar(data) => data.owner_id == sender_id,
                _ => false,
            };
            is_owned &&
            item.item_def_id == wood_item_def.id &&
            item.quantity > 0
        })
        .collect();
    
    // Calculate total wood available
    let total_wood: u32 = wood_items.iter().map(|item| item.quantity).sum();
    
    if total_wood < required_wood {
        // Emit error sound for instant feedback
        crate::sound_events::emit_error_resources_sound(ctx, player.position_x, player.position_y, sender_id);
        return Err(format!(
            "Not enough wood. Required: {}, Available: {}",
            required_wood, total_wood
        ));
    }
    
    // Consume wood (remove from inventory, starting with first item)
    let mut remaining_to_consume = required_wood;
    for wood_item in &wood_items {
        if remaining_to_consume == 0 {
            break;
        }
        
        let consume_from_this = remaining_to_consume.min(wood_item.quantity);
        let new_quantity = wood_item.quantity - consume_from_this;
        remaining_to_consume -= consume_from_this;
        
        if new_quantity == 0 {
            // Delete item if quantity reaches 0
            ctx.db.inventory_item().instance_id().delete(wood_item.instance_id);
        } else {
            // Update item with new quantity
            let mut updated_item = wood_item.clone();
            updated_item.quantity = new_quantity;
            ctx.db.inventory_item().instance_id().update(updated_item);
        }
    }
    
    log::info!("[PlaceFoundation] Consumed {} wood from player {:?}", required_wood, sender_id);
    
    // 9. Create and insert foundation
    let new_foundation = FoundationCell {
        id: 0, // Auto-incremented
        cell_x: cell_x_i32,
        cell_y: cell_y_i32,
        chunk_index,
        shape,
        tier,
        health: max_health,
        max_health,
        owner: sender_id,
        placed_at: ctx.timestamp,
        is_destroyed: false,
        destroyed_at: None,
        last_hit_time: None,
        last_damaged_by: None,
        group_id: None, // TODO: Implement group system
    };
    
    foundations.try_insert(new_foundation)
        .map_err(|e| format!("Failed to insert foundation: {}", e))?;
    
    // 10. Emit foundation construction sound for all nearby players
    crate::sound_events::emit_foundation_wood_constructed_sound(ctx, world_x, world_y, sender_id);
    
    log::info!(
        "[PlaceFoundation] Successfully placed foundation at cell ({}, {}), tier={:?}, health={:.1}",
        cell_x, cell_y, building_tier, max_health
    );
    
    Ok(())
}

/// Upgrade a foundation to a higher tier
#[spacetimedb::reducer]
pub fn upgrade_foundation(
    ctx: &ReducerContext,
    foundation_id: u64,
    new_tier: u8,
) -> Result<(), String> {
    let sender_id = ctx.sender;
    let players = ctx.db.player();
    let foundations = ctx.db.foundation_cell();
    
    log::info!(
        "[UpgradeFoundation] Player {:?} attempting to upgrade foundation {} to tier {}",
        sender_id, foundation_id, new_tier
    );
    
    // 1. Validate player
    let player = players.identity().find(&sender_id)
        .ok_or_else(|| "Player not found".to_string())?;
    
    if player.is_dead {
        return Err("Cannot upgrade foundation while dead.".to_string());
    }
    
    if player.is_knocked_out {
        return Err("Cannot upgrade foundation while knocked out.".to_string());
    }
    
    // 2. Validate Repair Hammer equipped
    if !player_has_repair_hammer(ctx, sender_id) {
        return Err("Repair Hammer must be equipped to upgrade foundations.".to_string());
    }
    
    // 2.5. Check building privilege AND distance from hearth
    use crate::homestead_hearth::{player_has_building_privilege, BUILDING_PRIVILEGE_RADIUS_SQUARED};
    if !player_has_building_privilege(ctx, sender_id) {
        return Err("Building privilege required. Hold E near a Homestead Hearth to gain building privilege.".to_string());
    }
    
    // Check if player is within building privilege radius of ANY hearth
    let hearths = ctx.db.homestead_hearth();
    let mut within_radius = false;
    for hearth in hearths.iter() {
        if hearth.is_destroyed {
            continue;
        }
        let dx = player.position_x - hearth.pos_x;
        let dy = player.position_y - hearth.pos_y;
        let distance_squared = dx * dx + dy * dy;
        if distance_squared <= BUILDING_PRIVILEGE_RADIUS_SQUARED {
            within_radius = true;
            break;
        }
    }
    
    if !within_radius {
        return Err("Too far from any Homestead Hearth. Building privilege only works within 500px of a hearth.".to_string());
    }
    
    // 3. Find foundation
    let foundation = foundations.id().find(&foundation_id)
        .ok_or_else(|| "Foundation not found".to_string())?;
    
    if foundation.is_destroyed {
        return Err("Cannot upgrade destroyed foundation.".to_string());
    }
    
    // 4. Validate new tier
    if !is_valid_building_tier(new_tier) {
        return Err(format!("Invalid building tier: {}. Must be 0-3 (Twig, Wood, Stone, Metal).", new_tier));
    }
    
    let current_tier = match foundation.tier {
        0 => BuildingTier::Twig,
        1 => BuildingTier::Wood,
        2 => BuildingTier::Stone,
        3 => BuildingTier::Metal,
        _ => return Err("Foundation has invalid tier".to_string()),
    };
    
    let target_tier = match new_tier {
        0 => BuildingTier::Twig,
        1 => BuildingTier::Wood,
        2 => BuildingTier::Stone,
        3 => BuildingTier::Metal,
        _ => return Err("Invalid target tier".to_string()),
    };
    
    // 5. Check if upgrade is valid (can only upgrade to higher tier)
    if target_tier as u8 <= current_tier as u8 {
        return Err(format!("Cannot downgrade foundation. Current tier: {:?}, Target tier: {:?}", current_tier, target_tier));
    }
    
    // 6. Check placement distance from player
    let world_x = (foundation.cell_x as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
    let world_y = (foundation.cell_y as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
    
    let dx = world_x - player.position_x;
    let dy = world_y - player.position_y;
    let dist_sq = dx * dx + dy * dy;
    
    if dist_sq > BUILDING_PLACEMENT_MAX_DISTANCE_SQUARED {
        return Err(format!(
            "Foundation upgrade too far from player. Distance: {:.1}px, Max: {:.1}px",
            dist_sq.sqrt(),
            BUILDING_PLACEMENT_MAX_DISTANCE
        ));
    }
    
    // 7. Calculate resource costs based on target tier and shape
    let inventory = ctx.db.inventory_item();
    let item_defs = ctx.db.item_definition();
    
    // Determine shape for cost calculation
    let foundation_shape = match foundation.shape {
        0 => FoundationShape::Empty,
        1 => FoundationShape::Full,
        2 => FoundationShape::TriNW,
        3 => FoundationShape::TriNE,
        4 => FoundationShape::TriSE,
        5 => FoundationShape::TriSW,
        _ => return Err("Foundation has invalid shape".to_string()),
    };
    
    let shape_multiplier = match foundation_shape {
        FoundationShape::Full => 1.0,
        FoundationShape::TriNW | FoundationShape::TriNE | FoundationShape::TriSE | FoundationShape::TriSW => 0.5,
        _ => 1.0,
    };
    
    // Resource costs per tier upgrade - minimal for foundations since they're purely aesthetic
    let (required_wood, required_stone, required_metal) = match target_tier {
        BuildingTier::Wood => {
            // Twig -> Wood: 10 wood for full, 5 for triangle (reduced from 50/25)
            ((10.0 * shape_multiplier) as u32, 0, 0)
        },
        BuildingTier::Stone => {
            // -> Stone: 20 stone for full, 10 for triangle (reduced from 100/50)
            (0, (20.0 * shape_multiplier) as u32, 0)
        },
        BuildingTier::Metal => {
            // -> Metal: 10 metal fragments for full, 5 for triangle (reduced from 50/25)
            (0, 0, (10.0 * shape_multiplier) as u32)
        },
        BuildingTier::Twig => {
            // Can't upgrade to Twig (it's the base tier)
            return Err("Cannot upgrade to Twig tier".to_string());
        },
    };
    
    // 8. Check and consume resources
    if required_wood > 0 {
        let wood_item_def = item_defs.iter()
            .find(|def| def.name == "Wood")
            .ok_or_else(|| "Wood item definition not found".to_string())?;
        
        let mut wood_items: Vec<_> = inventory.iter()
            .filter(|item| {
                let is_owned = match &item.location {
                    ItemLocation::Inventory(data) => data.owner_id == sender_id,
                    ItemLocation::Hotbar(data) => data.owner_id == sender_id,
                    _ => false,
                };
                is_owned &&
                item.item_def_id == wood_item_def.id &&
                item.quantity > 0
            })
            .collect();
        
        let total_wood: u32 = wood_items.iter().map(|item| item.quantity).sum();
        
        if total_wood < required_wood {
            // Emit error sound for instant feedback
            crate::sound_events::emit_error_resources_sound(ctx, player.position_x, player.position_y, sender_id);
            return Err(format!(
                "Not enough wood. Required: {}, Available: {}",
                required_wood, total_wood
            ));
        }
        
        // Consume wood
        let mut remaining_to_consume = required_wood;
        for wood_item in &wood_items {
            if remaining_to_consume == 0 {
                break;
            }
            
            let consume_from_this = remaining_to_consume.min(wood_item.quantity);
            let new_quantity = wood_item.quantity - consume_from_this;
            remaining_to_consume -= consume_from_this;
            
            if new_quantity == 0 {
                ctx.db.inventory_item().instance_id().delete(wood_item.instance_id);
            } else {
                let mut updated_item = wood_item.clone();
                updated_item.quantity = new_quantity;
                ctx.db.inventory_item().instance_id().update(updated_item);
            }
        }
        
        log::info!("[UpgradeFoundation] Consumed {} wood from player {:?}", required_wood, sender_id);
    }
    
    if required_stone > 0 {
        let stone_item_def = item_defs.iter()
            .find(|def| def.name == "Stone")
            .ok_or_else(|| "Stone item definition not found".to_string())?;
        
        let mut stone_items: Vec<_> = inventory.iter()
            .filter(|item| {
                let is_owned = match &item.location {
                    ItemLocation::Inventory(data) => data.owner_id == sender_id,
                    ItemLocation::Hotbar(data) => data.owner_id == sender_id,
                    _ => false,
                };
                is_owned &&
                item.item_def_id == stone_item_def.id &&
                item.quantity > 0
            })
            .collect();
        
        let total_stone: u32 = stone_items.iter().map(|item| item.quantity).sum();
        
        if total_stone < required_stone {
            // Emit error sound for instant feedback
            crate::sound_events::emit_error_resources_sound(ctx, player.position_x, player.position_y, sender_id);
            return Err(format!(
                "Not enough stone. Required: {}, Available: {}",
                required_stone, total_stone
            ));
        }
        
        // Consume stone
        let mut remaining_to_consume = required_stone;
        for stone_item in &stone_items {
            if remaining_to_consume == 0 {
                break;
            }
            
            let consume_from_this = remaining_to_consume.min(stone_item.quantity);
            let new_quantity = stone_item.quantity - consume_from_this;
            remaining_to_consume -= consume_from_this;
            
            if new_quantity == 0 {
                ctx.db.inventory_item().instance_id().delete(stone_item.instance_id);
            } else {
                let mut updated_item = stone_item.clone();
                updated_item.quantity = new_quantity;
                ctx.db.inventory_item().instance_id().update(updated_item);
            }
        }
        
        log::info!("[UpgradeFoundation] Consumed {} stone from player {:?}", required_stone, sender_id);
    }
    
    if required_metal > 0 {
        let metal_item_def = item_defs.iter()
            .find(|def| def.name == "Metal Fragments")
            .ok_or_else(|| "Metal Fragments item definition not found".to_string())?;
        
        let mut metal_items: Vec<_> = inventory.iter()
            .filter(|item| {
                let is_owned = match &item.location {
                    ItemLocation::Inventory(data) => data.owner_id == sender_id,
                    ItemLocation::Hotbar(data) => data.owner_id == sender_id,
                    _ => false,
                };
                is_owned &&
                item.item_def_id == metal_item_def.id &&
                item.quantity > 0
            })
            .collect();
        
        let total_metal: u32 = metal_items.iter().map(|item| item.quantity).sum();
        
        if total_metal < required_metal {
            // Emit error sound for instant feedback
            crate::sound_events::emit_error_resources_sound(ctx, player.position_x, player.position_y, sender_id);
            return Err(format!(
                "Not enough metal fragments. Required: {}, Available: {}",
                required_metal, total_metal
            ));
        }
        
        // Consume metal
        let mut remaining_to_consume = required_metal;
        for metal_item in &metal_items {
            if remaining_to_consume == 0 {
                break;
            }
            
            let consume_from_this = remaining_to_consume.min(metal_item.quantity);
            let new_quantity = metal_item.quantity - consume_from_this;
            remaining_to_consume -= consume_from_this;
            
            if new_quantity == 0 {
                ctx.db.inventory_item().instance_id().delete(metal_item.instance_id);
            } else {
                let mut updated_item = metal_item.clone();
                updated_item.quantity = new_quantity;
                ctx.db.inventory_item().instance_id().update(updated_item);
            }
        }
        
        log::info!("[UpgradeFoundation] Consumed {} metal fragments from player {:?}", required_metal, sender_id);
    }
    
    // 9. Update foundation tier and health
    let new_max_health = get_foundation_max_health(target_tier);
    let health_ratio = foundation.health / foundation.max_health;
    let new_health = new_max_health * health_ratio; // Preserve health percentage
    
    let mut updated_foundation = foundation.clone();
    updated_foundation.tier = new_tier;
    updated_foundation.max_health = new_max_health;
    updated_foundation.health = new_health;
    
    foundations.id().update(updated_foundation);
    
    // 10. Emit upgrade sound based on tier
    match target_tier {
        BuildingTier::Wood => {
            crate::sound_events::emit_foundation_wood_upgraded_sound(ctx, world_x, world_y, sender_id);
        },
        BuildingTier::Stone => {
            crate::sound_events::emit_foundation_stone_upgraded_sound(ctx, world_x, world_y, sender_id);
        },
        BuildingTier::Metal => {
            crate::sound_events::emit_foundation_metal_upgraded_sound(ctx, world_x, world_y, sender_id);
        },
        BuildingTier::Twig => {
            // Should not happen, but handle it
        },
    }
    
    log::info!(
        "[UpgradeFoundation] Successfully upgraded foundation {} from {:?} to {:?}, health={:.1}/{:.1}",
        foundation_id, current_tier, target_tier, new_health, new_max_health
    );
    
    Ok(())
}

/// Destroy a twig foundation (only twig foundations can be destroyed)
#[spacetimedb::reducer]
pub fn destroy_foundation(ctx: &ReducerContext, foundation_id: u64) -> Result<(), String> {
    use crate::sound_events;
    
    let sender_id = ctx.sender;
    let foundations = ctx.db.foundation_cell();
    let players = ctx.db.player();
    
    // 1. Validate player exists and is not knocked out
    let player = players.identity().find(&sender_id)
        .ok_or_else(|| "Player not found".to_string())?;
    
    if player.is_knocked_out {
        return Err("Cannot destroy foundation while knocked out.".to_string());
    }
    
    // 2. Validate Repair Hammer equipped
    if !player_has_repair_hammer(ctx, sender_id) {
        return Err("Repair Hammer must be equipped to destroy foundations.".to_string());
    }
    
    // 3. Find foundation
    let foundation = foundations.id().find(&foundation_id)
        .ok_or_else(|| "Foundation not found".to_string())?;
    
    if foundation.is_destroyed {
        return Err("Foundation is already destroyed.".to_string());
    }
    
    // 4. Only twig foundations can be destroyed
    if foundation.tier != 0 {
        return Err("Only twig foundations can be destroyed.".to_string());
    }
    
    // 4.5. Check ownership - only the player who placed it can destroy it
    if foundation.owner != sender_id {
        return Err("You can only destroy foundations that you built.".to_string());
    }
    
    // 4.6. Building privilege check: Only required if destroying OTHER players' structures
    // Own twig structures can be destroyed without building privilege (for early game setup)
    // But we already checked ownership above, so if we reach here, it's the player's own foundation
    // So we skip building privilege check for own twig foundations
    // (This allows players to destroy their own twig structures before placing a hearth)
    
    // 5. Check placement distance from player
    let world_x = (foundation.cell_x as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
    let world_y = (foundation.cell_y as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
    
    let dx = world_x - player.position_x;
    let dy = world_y - player.position_y;
    let dist_sq = dx * dx + dy * dy;
    
    if dist_sq > BUILDING_PLACEMENT_MAX_DISTANCE_SQUARED {
        return Err("Foundation is too far away.".to_string());
    }
    
    // 6. Mark foundation as destroyed
    let mut updated_foundation = foundation.clone();
    updated_foundation.is_destroyed = true;
    updated_foundation.destroyed_at = Some(ctx.timestamp);
    
    foundations.id().update(updated_foundation);
    
    // 6.5. CASCADING DESTRUCTION: Destroy all walls placed on this foundation
    let walls = ctx.db.wall_cell();
    let foundation_cell_x = foundation.cell_x;
    let foundation_cell_y = foundation.cell_y;
    
    let mut destroyed_wall_count = 0;
    for wall in walls.idx_cell_coords().filter((foundation_cell_x, foundation_cell_y)) {
        // Only destroy walls that aren't already destroyed
        if !wall.is_destroyed {
            let mut updated_wall = wall.clone();
            updated_wall.is_destroyed = true;
            updated_wall.destroyed_at = Some(ctx.timestamp);
            walls.id().update(updated_wall);
            destroyed_wall_count += 1;
            
            log::info!(
                "[DestroyFoundation] Cascading destruction: Destroyed wall {} on foundation {} at ({}, {})",
                wall.id, foundation_id, foundation_cell_x, foundation_cell_y
            );
        }
    }
    
    // 7. Emit destroy sound
    sound_events::emit_foundation_twig_destroyed_sound(ctx, world_x, world_y, sender_id);
    
    log::info!(
        "[DestroyFoundation] Successfully destroyed twig foundation {} at ({}, {}) and {} walls on it",
        foundation_id, foundation.cell_x, foundation.cell_y, destroyed_wall_count
    );
    
    Ok(())
}

/// Place a wall cell on the edge of a foundation tile
#[spacetimedb::reducer]
pub fn place_wall(
    ctx: &ReducerContext,
    cell_x: i64,
    cell_y: i64,
    world_x: f32,
    world_y: f32,
    tier: u8,
) -> Result<(), String> {
    let sender_id = ctx.sender;
    let players = ctx.db.player();
    let walls = ctx.db.wall_cell();
    let foundations = ctx.db.foundation_cell();
    
    log::info!(
        "[PlaceWall] Player {:?} attempting to place wall at cell ({}, {}), world=({:.1}, {:.1}), tier={}",
        sender_id, cell_x, cell_y, world_x, world_y, tier
    );
    
    // 1. Validate player
    let player = players.identity().find(&sender_id)
        .ok_or_else(|| "Player not found".to_string())?;
    
    if player.is_dead {
        return Err("Cannot place wall while dead.".to_string());
    }
    
    if player.is_knocked_out {
        return Err("Cannot place wall while knocked out.".to_string());
    }
    
    // 2. Validate Blueprint equipped
    if !player_has_blueprint(ctx, sender_id) {
        return Err("Blueprint must be equipped to place building pieces.".to_string());
    }
    
    // 3. Validate tier
    if !is_valid_building_tier(tier) {
        return Err(format!("Invalid building tier: {}. Must be 0-3 (Twig, Wood, Stone, Metal).", tier));
    }
    
    let building_tier = match tier {
        0 => BuildingTier::Twig,
        1 => BuildingTier::Wood,
        2 => BuildingTier::Stone,
        3 => BuildingTier::Metal,
        _ => return Err("Invalid building tier".to_string()),
    };
    
    // 4. Convert cell coordinates
    let cell_x_i32 = cell_x as i32;
    let cell_y_i32 = cell_y as i32;
    
    // 5. Get foundation shape FIRST (needed for edge determination)
    let mut foundation_shape = FoundationShape::Full;
    for foundation in foundations.idx_cell_coords().filter((cell_x_i32, cell_y_i32)) {
        if !foundation.is_destroyed {
            foundation_shape = match foundation.shape {
                0 => FoundationShape::Empty,
                1 => FoundationShape::Full,
                2 => FoundationShape::TriNW,
                3 => FoundationShape::TriNE,
                4 => FoundationShape::TriSE,
                5 => FoundationShape::TriSW,
                _ => FoundationShape::Full,
            };
            break;
        }
    }
    
    // 6. Determine edge and facing based on world position, player position, and foundation shape
    let (edge, facing) = determine_wall_edge_and_facing(
        world_x,
        world_y,
        cell_x_i32,
        cell_y_i32,
        player.position_x,
        player.position_y,
        foundation_shape,
    );
    
    // 7. Validate wall position (foundation exists, no overlapping wall)
    is_wall_position_valid(ctx, cell_x_i32, cell_y_i32, edge, facing)?;
    
    // 8. Check placement distance from player
    let tile_center_x = (cell_x_i32 as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
    let tile_center_y = (cell_y_i32 as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
    
    let dx = tile_center_x - player.position_x;
    let dy = tile_center_y - player.position_y;
    let dist_sq = dx * dx + dy * dy;
    
    if dist_sq > BUILDING_PLACEMENT_MAX_DISTANCE_SQUARED {
        return Err(format!(
            "Wall placement too far from player. Distance: {:.1}px, Max: {:.1}px",
            dist_sq.sqrt(),
            BUILDING_PLACEMENT_MAX_DISTANCE
        ));
    }
    
    // 9. Calculate chunk index
    let chunk_index = calculate_chunk_index(tile_center_x, tile_center_y);
    
    // 10. Get max health for this tier
    let max_health = get_wall_max_health(building_tier);
    
    // 11. Check and consume resources (Twig tier uses wood, cost: 15 wood per wall)
    let required_wood = 15;
    
    let inventory = ctx.db.inventory_item();
    let item_defs = ctx.db.item_definition();
    
    // Find "Wood" item definition
    let wood_item_def = item_defs.iter()
        .find(|def| def.name == "Wood")
        .ok_or_else(|| "Wood item definition not found".to_string())?;
    
    // Find wood items in player's inventory OR hotbar
    let mut wood_items: Vec<_> = inventory.iter()
        .filter(|item| {
            let is_owned = match &item.location {
                ItemLocation::Inventory(data) => data.owner_id == sender_id,
                ItemLocation::Hotbar(data) => data.owner_id == sender_id,
                _ => false,
            };
            is_owned &&
            item.item_def_id == wood_item_def.id &&
            item.quantity > 0
        })
        .collect();
    
    // Calculate total wood available
    let total_wood: u32 = wood_items.iter().map(|item| item.quantity).sum();
    
    if total_wood < required_wood {
        // Emit error sound for instant feedback
        crate::sound_events::emit_error_resources_sound(ctx, player.position_x, player.position_y, sender_id);
        return Err(format!(
            "Not enough wood. Required: {}, Available: {}",
            required_wood, total_wood
        ));
    }
    
    // Consume wood
    let mut remaining_to_consume = required_wood;
    for wood_item in &wood_items {
        if remaining_to_consume == 0 {
            break;
        }
        
        let consume_from_this = remaining_to_consume.min(wood_item.quantity);
        let new_quantity = wood_item.quantity - consume_from_this;
        remaining_to_consume -= consume_from_this;
        
        if new_quantity == 0 {
            ctx.db.inventory_item().instance_id().delete(wood_item.instance_id);
        } else {
            let mut updated_item = wood_item.clone();
            updated_item.quantity = new_quantity;
            ctx.db.inventory_item().instance_id().update(updated_item);
        }
    }
    
    log::info!("[PlaceWall] Consumed {} wood from player {:?}", required_wood, sender_id);
    
    // 12. Create and insert wall
    let new_wall = WallCell {
        id: 0, // Auto-incremented
        cell_x: cell_x_i32,
        cell_y: cell_y_i32,
        chunk_index,
        edge: edge as u8,
        facing: facing as u8,
        foundation_shape: foundation_shape as u8,
        tier,
        health: max_health,
        max_health,
        owner: sender_id,
        placed_at: ctx.timestamp,
        is_destroyed: false,
        destroyed_at: None,
        last_hit_time: None,
        last_damaged_by: None,
        group_id: None,
    };
    
    walls.try_insert(new_wall)
        .map_err(|e| format!("Failed to insert wall: {}", e))?;
    
    // 13. Emit foundation construction sound (walls use same sound as foundations)
    crate::sound_events::emit_foundation_wood_constructed_sound(ctx, tile_center_x, tile_center_y, sender_id);
    
    log::info!(
        "[PlaceWall] Successfully placed wall at cell ({}, {}), edge={:?}, facing={:?}, tier={:?}, health={:.1}",
        cell_x, cell_y, edge, facing, building_tier, max_health
    );
    
    Ok(())
}

/// Upgrade a wall to a higher tier
#[spacetimedb::reducer]
pub fn upgrade_wall(
    ctx: &ReducerContext,
    wall_id: u64,
    new_tier: u8,
) -> Result<(), String> {
    let sender_id = ctx.sender;
    let players = ctx.db.player();
    let walls = ctx.db.wall_cell();
    
    log::info!(
        "[UpgradeWall] Player {:?} attempting to upgrade wall {} to tier {}",
        sender_id, wall_id, new_tier
    );
    
    // 1. Validate player
    let player = players.identity().find(&sender_id)
        .ok_or_else(|| "Player not found".to_string())?;
    
    if player.is_dead {
        return Err("Cannot upgrade wall while dead.".to_string());
    }
    
    if player.is_knocked_out {
        return Err("Cannot upgrade wall while knocked out.".to_string());
    }
    
    // 2. Validate Repair Hammer equipped
    if !player_has_repair_hammer(ctx, sender_id) {
        return Err("Repair Hammer must be equipped to upgrade walls.".to_string());
    }
    
    // 2.5. Check building privilege AND distance from hearth
    use crate::homestead_hearth::{player_has_building_privilege, BUILDING_PRIVILEGE_RADIUS_SQUARED};
    if !player_has_building_privilege(ctx, sender_id) {
        return Err("Building privilege required. Hold E near a Homestead Hearth to gain building privilege.".to_string());
    }
    
    // Check if player is within building privilege radius of ANY hearth
    let hearths = ctx.db.homestead_hearth();
    let mut within_radius = false;
    for hearth in hearths.iter() {
        if hearth.is_destroyed {
            continue;
        }
        let dx = player.position_x - hearth.pos_x;
        let dy = player.position_y - hearth.pos_y;
        let distance_squared = dx * dx + dy * dy;
        if distance_squared <= BUILDING_PRIVILEGE_RADIUS_SQUARED {
            within_radius = true;
            break;
        }
    }
    
    if !within_radius {
        return Err("Too far from any Homestead Hearth. Building privilege only works within 500px of a hearth.".to_string());
    }
    
    // 3. Find wall
    let wall = walls.id().find(&wall_id)
        .ok_or_else(|| "Wall not found".to_string())?;
    
    if wall.is_destroyed {
        return Err("Cannot upgrade destroyed wall.".to_string());
    }
    
    // 4. Validate new tier
    if !is_valid_building_tier(new_tier) {
        return Err(format!("Invalid building tier: {}. Must be 0-3 (Twig, Wood, Stone, Metal).", new_tier));
    }
    
    let current_tier = match wall.tier {
        0 => BuildingTier::Twig,
        1 => BuildingTier::Wood,
        2 => BuildingTier::Stone,
        3 => BuildingTier::Metal,
        _ => return Err("Invalid current wall tier".to_string()),
    };
    
    let target_tier = match new_tier {
        0 => BuildingTier::Twig,
        1 => BuildingTier::Wood,
        2 => BuildingTier::Stone,
        3 => BuildingTier::Metal,
        _ => return Err("Invalid target tier".to_string()),
    };
    
    // 5. Ensure upgrade is to a higher tier
    if new_tier <= wall.tier {
        return Err(format!("Cannot downgrade wall. Current tier: {}, Target tier: {}", wall.tier, new_tier));
    }
    
    // 6. Check placement distance from player
    let world_x = (wall.cell_x as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
    let world_y = (wall.cell_y as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
    
    let dx = world_x - player.position_x;
    let dy = world_y - player.position_y;
    let dist_sq = dx * dx + dy * dy;
    
    if dist_sq > BUILDING_PLACEMENT_MAX_DISTANCE_SQUARED {
        return Err("Wall is too far away.".to_string());
    }
    
    // 7. Calculate resource costs based on target tier
    let inventory = ctx.db.inventory_item();
    let item_defs = ctx.db.item_definition();
    
    // Wall costs: Wood tier = 20 wood, Stone tier = 20 stone, Metal tier = 20 metal fragments
    let required_wood = if target_tier == BuildingTier::Wood { 20 } else { 0 };
    let required_stone = if target_tier == BuildingTier::Stone { 20 } else { 0 };
    let required_metal = if target_tier == BuildingTier::Metal { 20 } else { 0 };
    
    // Check and consume wood
    if required_wood > 0 {
        let wood_item_def = item_defs.iter()
            .find(|def| def.name == "Wood")
            .ok_or_else(|| "Wood item definition not found".to_string())?;
        
        let mut wood_items: Vec<_> = inventory.iter()
            .filter(|item| {
                let is_owned = match &item.location {
                    ItemLocation::Inventory(data) => data.owner_id == sender_id,
                    ItemLocation::Hotbar(data) => data.owner_id == sender_id,
                    _ => false,
                };
                is_owned &&
                item.item_def_id == wood_item_def.id &&
                item.quantity > 0
            })
            .collect();
        
        let total_wood: u32 = wood_items.iter().map(|item| item.quantity).sum();
        
        if total_wood < required_wood {
            // Emit error sound for instant feedback
            crate::sound_events::emit_error_resources_sound(ctx, player.position_x, player.position_y, sender_id);
            return Err(format!(
                "Not enough wood. Required: {}, Available: {}",
                required_wood, total_wood
            ));
        }
        
        let mut remaining_to_consume = required_wood;
        for wood_item in &wood_items {
            if remaining_to_consume == 0 {
                break;
            }
            
            let consume_from_this = remaining_to_consume.min(wood_item.quantity);
            let new_quantity = wood_item.quantity - consume_from_this;
            remaining_to_consume -= consume_from_this;
            
            if new_quantity == 0 {
                ctx.db.inventory_item().instance_id().delete(wood_item.instance_id);
            } else {
                let mut updated_item = wood_item.clone();
                updated_item.quantity = new_quantity;
                ctx.db.inventory_item().instance_id().update(updated_item);
            }
        }
        
        log::info!("[UpgradeWall] Consumed {} wood from player {:?}", required_wood, sender_id);
    }
    
    // Check and consume stone
    if required_stone > 0 {
        let stone_item_def = item_defs.iter()
            .find(|def| def.name == "Stone")
            .ok_or_else(|| "Stone item definition not found".to_string())?;
        
        let mut stone_items: Vec<_> = inventory.iter()
            .filter(|item| {
                let is_owned = match &item.location {
                    ItemLocation::Inventory(data) => data.owner_id == sender_id,
                    ItemLocation::Hotbar(data) => data.owner_id == sender_id,
                    _ => false,
                };
                is_owned &&
                item.item_def_id == stone_item_def.id &&
                item.quantity > 0
            })
            .collect();
        
        let total_stone: u32 = stone_items.iter().map(|item| item.quantity).sum();
        
        if total_stone < required_stone {
            // Emit error sound for instant feedback
            crate::sound_events::emit_error_resources_sound(ctx, player.position_x, player.position_y, sender_id);
            return Err(format!(
                "Not enough stone. Required: {}, Available: {}",
                required_stone, total_stone
            ));
        }
        
        let mut remaining_to_consume = required_stone;
        for stone_item in &stone_items {
            if remaining_to_consume == 0 {
                break;
            }
            
            let consume_from_this = remaining_to_consume.min(stone_item.quantity);
            let new_quantity = stone_item.quantity - consume_from_this;
            remaining_to_consume -= consume_from_this;
            
            if new_quantity == 0 {
                ctx.db.inventory_item().instance_id().delete(stone_item.instance_id);
            } else {
                let mut updated_item = stone_item.clone();
                updated_item.quantity = new_quantity;
                ctx.db.inventory_item().instance_id().update(updated_item);
            }
        }
        
        log::info!("[UpgradeWall] Consumed {} stone from player {:?}", required_stone, sender_id);
    }
    
    // Check and consume metal fragments
    if required_metal > 0 {
        let metal_item_def = item_defs.iter()
            .find(|def| def.name == "Metal Fragments")
            .ok_or_else(|| "Metal Fragments item definition not found".to_string())?;
        
        let mut metal_items: Vec<_> = inventory.iter()
            .filter(|item| {
                let is_owned = match &item.location {
                    ItemLocation::Inventory(data) => data.owner_id == sender_id,
                    ItemLocation::Hotbar(data) => data.owner_id == sender_id,
                    _ => false,
                };
                is_owned &&
                item.item_def_id == metal_item_def.id &&
                item.quantity > 0
            })
            .collect();
        
        let total_metal: u32 = metal_items.iter().map(|item| item.quantity).sum();
        
        if total_metal < required_metal {
            // Emit error sound for instant feedback
            crate::sound_events::emit_error_resources_sound(ctx, player.position_x, player.position_y, sender_id);
            return Err(format!(
                "Not enough metal fragments. Required: {}, Available: {}",
                required_metal, total_metal
            ));
        }
        
        let mut remaining_to_consume = required_metal;
        for metal_item in &metal_items {
            if remaining_to_consume == 0 {
                break;
            }
            
            let consume_from_this = remaining_to_consume.min(metal_item.quantity);
            let new_quantity = metal_item.quantity - consume_from_this;
            remaining_to_consume -= consume_from_this;
            
            if new_quantity == 0 {
                ctx.db.inventory_item().instance_id().delete(metal_item.instance_id);
            } else {
                let mut updated_item = metal_item.clone();
                updated_item.quantity = new_quantity;
                ctx.db.inventory_item().instance_id().update(updated_item);
            }
        }
        
        log::info!("[UpgradeWall] Consumed {} metal fragments from player {:?}", required_metal, sender_id);
    }
    
    // 8. Update wall tier and health
    let new_max_health = get_wall_max_health(target_tier);
    let health_ratio = wall.health / wall.max_health;
    let new_health = new_max_health * health_ratio; // Preserve health percentage
    
    let mut updated_wall = wall.clone();
    updated_wall.tier = new_tier;
    updated_wall.max_health = new_max_health;
    updated_wall.health = new_health;
    
    walls.id().update(updated_wall);
    
    // 9. Emit upgrade sound based on tier
    match target_tier {
        BuildingTier::Wood => {
            crate::sound_events::emit_foundation_wood_upgraded_sound(ctx, world_x, world_y, sender_id);
        },
        BuildingTier::Stone => {
            crate::sound_events::emit_foundation_stone_upgraded_sound(ctx, world_x, world_y, sender_id);
        },
        BuildingTier::Metal => {
            crate::sound_events::emit_foundation_metal_upgraded_sound(ctx, world_x, world_y, sender_id);
        },
        BuildingTier::Twig => {
            // Should not happen, but handle it
        },
    }
    
    log::info!(
        "[UpgradeWall] Successfully upgraded wall {} from {:?} to {:?}, health={:.1}/{:.1}",
        wall_id, current_tier, target_tier, new_health, new_max_health
    );
    
    Ok(())
}

/// Destroy a twig wall (only twig walls can be destroyed)
#[spacetimedb::reducer]
pub fn destroy_wall(ctx: &ReducerContext, wall_id: u64) -> Result<(), String> {
    use crate::sound_events;
    
    let sender_id = ctx.sender;
    let walls = ctx.db.wall_cell();
    let players = ctx.db.player();
    
    // 1. Validate player exists and is not knocked out
    let player = players.identity().find(&sender_id)
        .ok_or_else(|| "Player not found".to_string())?;
    
    if player.is_knocked_out {
        return Err("Cannot destroy wall while knocked out.".to_string());
    }
    
    // 2. Validate Repair Hammer equipped
    if !player_has_repair_hammer(ctx, sender_id) {
        return Err("Repair Hammer must be equipped to destroy walls.".to_string());
    }
    
    // 3. Find wall
    let wall = walls.id().find(&wall_id)
        .ok_or_else(|| "Wall not found".to_string())?;
    
    if wall.is_destroyed {
        return Err("Wall is already destroyed.".to_string());
    }
    
    // 4. Only twig walls can be destroyed
    if wall.tier != 0 {
        return Err("Only twig walls can be destroyed.".to_string());
    }
    
    // 4.5. Check ownership - only the player who placed it can destroy it
    if wall.owner != sender_id {
        return Err("You can only destroy walls that you built.".to_string());
    }
    
    // 4.6. Building privilege check: Only required if destroying OTHER players' structures
    // Own twig structures can be destroyed without building privilege (for early game setup)
    // But we already checked ownership above, so if we reach here, it's the player's own wall
    // So we skip building privilege check for own twig walls
    // (This allows players to destroy their own twig structures before placing a hearth)
    
    // 5. Check placement distance from player
    let world_x = (wall.cell_x as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
    let world_y = (wall.cell_y as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
    
    let dx = world_x - player.position_x;
    let dy = world_y - player.position_y;
    let dist_sq = dx * dx + dy * dy;
    
    if dist_sq > BUILDING_PLACEMENT_MAX_DISTANCE_SQUARED {
        return Err("Wall is too far away.".to_string());
    }
    
    // 6. Mark wall as destroyed
    let mut updated_wall = wall.clone();
    updated_wall.is_destroyed = true;
    updated_wall.destroyed_at = Some(ctx.timestamp);
    
    walls.id().update(updated_wall);
    
    // 7. Emit destroy sound (using foundation destroy sound for now)
    sound_events::emit_foundation_twig_destroyed_sound(ctx, world_x, world_y, sender_id);
    
    log::info!(
        "[DestroyWall] Successfully destroyed twig wall {} at ({}, {})",
        wall_id, wall.cell_x, wall.cell_y
    );
    
    Ok(())
}

// --- Wall Damage Function ---

/// Applies weapon damage to a wall (called from combat system or projectile collision)
pub fn damage_wall(
    ctx: &ReducerContext,
    attacker_id: Identity,
    wall_id: u64,
    damage: f32,
    timestamp: Timestamp,
) -> Result<(), String> {
    let walls = ctx.db.wall_cell();
    
    // Find the wall
    let mut wall = walls.id().find(&wall_id)
        .ok_or_else(|| format!("Wall with ID {} not found.", wall_id))?;
    
    if wall.is_destroyed {
        return Err("Wall is already destroyed.".to_string());
    }
    
    let old_health = wall.health;
    wall.health = (wall.health - damage).max(0.0);
    wall.last_hit_time = Some(timestamp);
    wall.last_damaged_by = Some(attacker_id);
    
    log::info!(
        "Player {:?} hit Wall {} for {:.1} damage. Health: {:.1} -> {:.1}",
        attacker_id, wall_id, damage, old_health, wall.health
    );
    
    if wall.health <= 0.0 {
        // Wall destroyed
        wall.health = 0.0;
        wall.is_destroyed = true;
        wall.destroyed_at = Some(timestamp);
        
        log::info!("[WallDamage] Wall {} destroyed by player {:?}", wall_id, attacker_id);
        
        // Emit destruction sound (use twig destroyed sound for all tiers, or melee hit sound)
        let world_x = (wall.cell_x as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
        let world_y = (wall.cell_y as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
        
        // Use foundation twig destroyed sound for all wall tiers (or could use melee hit sound)
        crate::sound_events::emit_foundation_twig_destroyed_sound(ctx, world_x, world_y, attacker_id);
    } else {
        // Wall damaged but not destroyed
        log::info!("[WallDamage] Wall {} damaged, health: {:.1}", wall_id, wall.health);
        
        // Emit hit sound (use melee hit sound for all tiers)
        let world_x = (wall.cell_x as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
        let world_y = (wall.cell_y as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
        
        // Use melee hit sound for wall hits (similar to other structures)
        crate::sound_events::emit_melee_hit_sharp_sound(ctx, world_x, world_y, attacker_id);
    }
    
    // Update the wall
    walls.id().update(wall);
    
    Ok(())
}

// --- Projectile and Melee Collision Detection ---

/// Checks if a moving entity (circle) collides with any walls along a path
/// Returns Some((wall_id, collision_x, collision_y)) if collision occurs
/// This performs a continuous collision detection (sweep) to prevent tunneling
pub fn check_entity_path_collision(
    ctx: &ReducerContext,
    start_x: f32,
    start_y: f32,
    end_x: f32,
    end_y: f32,
    radius: f32,
) -> Option<(u64, f32, f32)> {
    const WALL_COLLISION_THICKNESS: f32 = 6.0;
    
    let walls = ctx.db.wall_cell();
    
    // Calculate bounding box of the movement
    let min_x = start_x.min(end_x) - radius;
    let max_x = start_x.max(end_x) + radius;
    let min_y = start_y.min(end_y) - radius;
    let max_y = start_y.max(end_y) + radius;
    
    // Determine grid cells to check (include padding for radius)
    let start_tile_x = ((min_x - FOUNDATION_TILE_SIZE_PX as f32) / FOUNDATION_TILE_SIZE_PX as f32).floor() as i32;
    let end_tile_x = ((max_x + FOUNDATION_TILE_SIZE_PX as f32) / FOUNDATION_TILE_SIZE_PX as f32).ceil() as i32;
    let start_tile_y = ((min_y - FOUNDATION_TILE_SIZE_PX as f32) / FOUNDATION_TILE_SIZE_PX as f32).floor() as i32;
    let end_tile_y = ((max_y + FOUNDATION_TILE_SIZE_PX as f32) / FOUNDATION_TILE_SIZE_PX as f32).ceil() as i32;
    
    let mut closest_collision: Option<(u64, f32, f32, f32)> = None; // (id, x, y, dist_sq)
    
    for tile_x in start_tile_x..=end_tile_x {
        for tile_y in start_tile_y..=end_tile_y {
            // Find walls on this tile
            for wall in walls.idx_cell_coords().filter((tile_x, tile_y)) {
                if wall.is_destroyed {
                    continue;
                }
                
                // Calculate wall edge collision bounds
                let tile_left = tile_x as f32 * FOUNDATION_TILE_SIZE_PX as f32;
                let tile_top = tile_y as f32 * FOUNDATION_TILE_SIZE_PX as f32;
                let tile_right = tile_left + FOUNDATION_TILE_SIZE_PX as f32;
                let tile_bottom = tile_top + FOUNDATION_TILE_SIZE_PX as f32;
                
                // Determine wall bounds based on edge
                let (wall_min_x, wall_max_x, wall_min_y, wall_max_y) = match wall.edge {
                    0 => (tile_left, tile_right, tile_top - WALL_COLLISION_THICKNESS/2.0, tile_top + WALL_COLLISION_THICKNESS/2.0), // N
                    1 => (tile_right - WALL_COLLISION_THICKNESS/2.0, tile_right + WALL_COLLISION_THICKNESS/2.0, tile_top, tile_bottom), // E
                    2 => (tile_left, tile_right, tile_bottom - WALL_COLLISION_THICKNESS/2.0, tile_bottom + WALL_COLLISION_THICKNESS/2.0), // S
                    3 => (tile_left - WALL_COLLISION_THICKNESS/2.0, tile_left + WALL_COLLISION_THICKNESS/2.0, tile_top, tile_bottom), // W
                    _ => continue,
                };
                
                // Expand wall AABB by entity radius for "circle cast"
                // This effectively checks if the center of the entity path intersects the expanded wall
                let expanded_min_x = wall_min_x - radius;
                let expanded_max_x = wall_max_x + radius;
                let expanded_min_y = wall_min_y - radius;
                let expanded_max_y = wall_max_y + radius;
                
                if line_intersects_aabb(start_x, start_y, end_x, end_y, expanded_min_x, expanded_max_x, expanded_min_y, expanded_max_y) {
                    // Calculate intersection point (closest point on the wall AABB to the start)
                    // This is a simplification - for true circle cast we'd solve quadratic, 
                    // but checking expanded AABB intersection is standard for 2D top-down
                    
                    // Clamp start/end to the expanded box to find rough collision point
                    let collision_x = end_x.max(expanded_min_x).min(expanded_max_x);
                    let collision_y = end_y.max(expanded_min_y).min(expanded_max_y);
                    
                    let dist_sq = (collision_x - start_x).powi(2) + (collision_y - start_y).powi(2);
                    
                    // Keep only the closest collision
                    match closest_collision {
                        Some((_, _, _, best_dist)) => {
                            if dist_sq < best_dist {
                                closest_collision = Some((wall.id, collision_x, collision_y, dist_sq));
                            }
                        }
                        None => {
                            closest_collision = Some((wall.id, collision_x, collision_y, dist_sq));
                        }
                    }
                }
            }
        }
    }
    
    closest_collision.map(|(id, x, y, _)| (id, x, y))
}

/// Checks if a line segment intersects with a wall edge
/// Returns Some((wall_id, collision_x, collision_y)) if collision occurs
pub fn check_projectile_wall_collision(
    ctx: &ReducerContext,
    start_x: f32,
    start_y: f32,
    end_x: f32,
    end_y: f32,
) -> Option<(u64, f32, f32)> {
    const WALL_COLLISION_THICKNESS: f32 = 6.0; // Same as player collision
    
    let walls = ctx.db.wall_cell();
    
    // Calculate which tiles to check (within 2 tiles of line segment)
    let min_x = start_x.min(end_x);
    let max_x = start_x.max(end_x);
    let min_y = start_y.min(end_y);
    let max_y = start_y.max(end_y);
    
    let start_tile_x = ((min_x - 96.0) / TILE_SIZE_PX as f32).floor() as i32;
    let end_tile_x = ((max_x + 96.0) / TILE_SIZE_PX as f32).ceil() as i32;
    let start_tile_y = ((min_y - 96.0) / TILE_SIZE_PX as f32).floor() as i32;
    let end_tile_y = ((max_y + 96.0) / TILE_SIZE_PX as f32).ceil() as i32;
    
    for tile_x in start_tile_x..=end_tile_x {
        for tile_y in start_tile_y..=end_tile_y {
            // Find walls on this tile
            for wall in walls.idx_cell_coords().filter((tile_x, tile_y)) {
                if wall.is_destroyed {
                    continue;
                }
                
                // Calculate wall edge collision bounds
                let tile_left = tile_x as f32 * TILE_SIZE_PX as f32;
                let tile_top = tile_y as f32 * TILE_SIZE_PX as f32;
                let tile_right = tile_left + TILE_SIZE_PX as f32;
                let tile_bottom = tile_top + TILE_SIZE_PX as f32;
                
                // Determine wall edge bounds based on edge direction
                // Edge 0 = North (top), 1 = East (right), 2 = South (bottom), 3 = West (left)
                let (wall_min_x, wall_max_x, wall_min_y, wall_max_y) = match wall.edge {
                    0 => { // North (top edge) - horizontal line
                        (tile_left, tile_right, tile_top - WALL_COLLISION_THICKNESS / 2.0, tile_top + WALL_COLLISION_THICKNESS / 2.0)
                    },
                    1 => { // East (right edge) - vertical line
                        (tile_right - WALL_COLLISION_THICKNESS / 2.0, tile_right + WALL_COLLISION_THICKNESS / 2.0, tile_top, tile_bottom)
                    },
                    2 => { // South (bottom edge) - horizontal line
                        (tile_left, tile_right, tile_bottom - WALL_COLLISION_THICKNESS / 2.0, tile_bottom + WALL_COLLISION_THICKNESS / 2.0)
                    },
                    3 => { // West (left edge) - vertical line
                        (tile_left - WALL_COLLISION_THICKNESS / 2.0, tile_left + WALL_COLLISION_THICKNESS / 2.0, tile_top, tile_bottom)
                    },
                    _ => continue, // Skip invalid edges
                };
                
                // Check if line segment intersects wall AABB
                if line_intersects_aabb(start_x, start_y, end_x, end_y, wall_min_x, wall_max_x, wall_min_y, wall_max_y) {
                    // Calculate approximate collision point
                    let collision_x = end_x.max(wall_min_x).min(wall_max_x);
                    let collision_y = end_y.max(wall_min_y).min(wall_max_y);
                    
                    log::info!(
                        "[ProjectileCollision] Projectile path from ({:.1}, {:.1}) to ({:.1}, {:.1}) hits Wall {} at ({:.1}, {:.1})",
                        start_x, start_y, end_x, end_y, wall.id, collision_x, collision_y
                    );
                    
                    return Some((wall.id, collision_x, collision_y));
                }
            }
        }
    }
    
    None
}

/// Checks if a line segment is blocked by walls (for melee attacks)
/// Returns Some(wall_id) if a wall is hit, None otherwise
pub fn check_line_hits_wall(
    ctx: &ReducerContext,
    start_x: f32,
    start_y: f32,
    end_x: f32,
    end_y: f32,
) -> Option<u64> {
    check_projectile_wall_collision(ctx, start_x, start_y, end_x, end_y)
        .map(|(wall_id, _, _)| wall_id)
}

/// Checks if a line segment is blocked by walls (for melee attacks)
/// Legacy function for backward compatibility - use check_line_hits_wall() for new code
pub fn is_line_blocked_by_walls(
    ctx: &ReducerContext,
    start_x: f32,
    start_y: f32,
    end_x: f32,
    end_y: f32,
) -> bool {
    check_line_hits_wall(ctx, start_x, start_y, end_x, end_y).is_some()
}

/// Checks if a world position is on any foundation (for blocking placement)
pub fn is_position_on_foundation(
    ctx: &ReducerContext,
    world_x: f32,
    world_y: f32,
) -> bool {
    // Convert world position to foundation cell coordinates
    let cell_x = (world_x / FOUNDATION_TILE_SIZE_PX as f32).floor() as i32;
    let cell_y = (world_y / FOUNDATION_TILE_SIZE_PX as f32).floor() as i32;
    
    // Check if there's a foundation at this cell
    for foundation in ctx.db.foundation_cell().iter() {
        if foundation.is_destroyed {
            continue;
        }
        
        if foundation.cell_x == cell_x && foundation.cell_y == cell_y {
            return true;
        }
    }
    
    false
}

/// Checks if a world position is too close to any wall (with buffer zone)
/// Used to prevent placing placeables on or near walls
/// Returns true if the position is within the buffer zone around a wall, false otherwise
pub fn is_position_on_wall(
    ctx: &ReducerContext,
    world_x: f32,
    world_y: f32,
) -> bool {
    const WALL_COLLISION_THICKNESS: f32 = 6.0;
    const PLACEMENT_BUFFER: f32 = 24.0; // Buffer zone around walls (prevents placing too close on either side)
    
    let walls = ctx.db.wall_cell();
    
    // Convert world position to foundation cell coordinates
    let cell_x = (world_x / FOUNDATION_TILE_SIZE_PX as f32).floor() as i32;
    let cell_y = (world_y / FOUNDATION_TILE_SIZE_PX as f32).floor() as i32;
    
    // Check walls in nearby cells (1 cell in each direction to catch edge cases)
    for offset_x in -1..=1 {
        for offset_y in -1..=1 {
            let check_cell_x = cell_x + offset_x;
            let check_cell_y = cell_y + offset_y;
            
            for wall in walls.idx_cell_coords().filter((check_cell_x, check_cell_y)) {
                if wall.is_destroyed {
                    continue;
                }
                
                // Calculate wall edge collision bounds using foundation cell coordinates
                let tile_left = check_cell_x as f32 * FOUNDATION_TILE_SIZE_PX as f32;
                let tile_top = check_cell_y as f32 * FOUNDATION_TILE_SIZE_PX as f32;
                let tile_right = tile_left + FOUNDATION_TILE_SIZE_PX as f32;
                let tile_bottom = tile_top + FOUNDATION_TILE_SIZE_PX as f32;
                
                // Determine wall edge bounds with buffer zone on both sides
                // Edge 0 = North (top), 1 = East (right), 2 = South (bottom), 3 = West (left)
                // Buffer extends on both interior and exterior sides of the wall
                let (wall_min_x, wall_max_x, wall_min_y, wall_max_y) = match wall.edge {
                    0 => { // North (top edge) - horizontal line
                        // Buffer extends both north (exterior) and south (interior) of the wall
                        (tile_left, tile_right, tile_top - WALL_COLLISION_THICKNESS / 2.0 - PLACEMENT_BUFFER, tile_top + WALL_COLLISION_THICKNESS / 2.0 + PLACEMENT_BUFFER)
                    },
                    1 => { // East (right edge) - vertical line
                        // Buffer extends both east (exterior) and west (interior) of the wall
                        (tile_right - WALL_COLLISION_THICKNESS / 2.0 - PLACEMENT_BUFFER, tile_right + WALL_COLLISION_THICKNESS / 2.0 + PLACEMENT_BUFFER, tile_top, tile_bottom)
                    },
                    2 => { // South (bottom edge) - horizontal line
                        // Buffer extends both south (exterior) and north (interior) of the wall
                        (tile_left, tile_right, tile_bottom - WALL_COLLISION_THICKNESS / 2.0 - PLACEMENT_BUFFER, tile_bottom + WALL_COLLISION_THICKNESS / 2.0 + PLACEMENT_BUFFER)
                    },
                    3 => { // West (left edge) - vertical line
                        // Buffer extends both west (exterior) and east (interior) of the wall
                        (tile_left - WALL_COLLISION_THICKNESS / 2.0 - PLACEMENT_BUFFER, tile_left + WALL_COLLISION_THICKNESS / 2.0 + PLACEMENT_BUFFER, tile_top, tile_bottom)
                    },
                    _ => continue, // Skip invalid edges
                };
                
                // Check if placement position is within wall collision bounds (including buffer)
                if world_x >= wall_min_x && world_x <= wall_max_x &&
                   world_y >= wall_min_y && world_y <= wall_max_y {
                    return true;
                }
            }
        }
    }
    
    false
}

/// Helper function: Checks if a line segment intersects with an AABB
fn line_intersects_aabb(
    x1: f32, y1: f32, x2: f32, y2: f32,
    left: f32, right: f32, top: f32, bottom: f32
) -> bool {
    let dx = x2 - x1;
    let dy = y2 - y1;
    
    // If line is a point, check if it's inside the AABB
    if dx.abs() < 0.001 && dy.abs() < 0.001 {
        return x1 >= left && x1 <= right && y1 >= top && y1 <= bottom;
    }
    
    let mut t_min: f32 = 0.0;
    let mut t_max: f32 = 1.0;
    
    // Check X bounds
    if dx.abs() > 0.001 {
        let t1 = (left - x1) / dx;
        let t2 = (right - x1) / dx;
        let t_near = t1.min(t2);
        let t_far = t1.max(t2);
        
        t_min = t_min.max(t_near);
        t_max = t_max.min(t_far);
        
        if t_min > t_max {
            return false;
        }
    } else {
        // Line is vertical, check if it's within X bounds
        if x1 < left || x1 > right {
            return false;
        }
    }
    
    // Check Y bounds
    if dy.abs() > 0.001 {
        let t1 = (top - y1) / dy;
        let t2 = (bottom - y1) / dy;
        let t_near = t1.min(t2);
        let t_far = t1.max(t2);
        
        t_min = t_min.max(t_near);
        t_max = t_max.min(t_far);
        
        if t_min > t_max {
            return false;
        }
    } else {
        // Line is horizontal, check if it's within Y bounds
        if y1 < top || y1 > bottom {
            return false;
        }
    }
    
    true // Line intersects AABB
}
