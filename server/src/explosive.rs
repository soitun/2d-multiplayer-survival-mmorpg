/******************************************************************************
 *                                                                            *
 * Explosive System - Handles placement and detonation of raiding explosives *
 * Two tiers: Babushka's Surprise (Tier 1) and Matriarch's Wrath (Tier 2)    *
 *                                                                            *
 ******************************************************************************/

use spacetimedb::{table, reducer, ReducerContext, Identity, Timestamp, ScheduleAt, Table, TimeDuration};
use log;
use rand::Rng;

use crate::environment::calculate_chunk_index;
use crate::utils::get_distance_squared;
use crate::models::ItemLocation;
use crate::items::{inventory_item, item_definition, ItemDefinition};
use crate::player;
use crate::door::door;
use crate::campfire::campfire;
use crate::furnace::furnace;
use crate::wooden_storage_box::wooden_storage_box;
use crate::shelter::shelter;
// Import building table traits (auto-generated by SpacetimeDB)
use crate::building::wall_cell;
use crate::building::foundation_cell;

// Additional table traits for explosion damage
use crate::tree::tree;
use crate::stone::stone;
use crate::grass::{grass, grass_respawn_schedule, GrassRespawnData, GrassRespawnSchedule, MIN_GRASS_RESPAWN_TIME_SECS, MAX_GRASS_RESPAWN_TIME_SECS};
use crate::barrel::barrel;
use crate::lantern::lantern;
use crate::stash::stash;
use crate::sleeping_bag::sleeping_bag;
use crate::rain_collector::rain_collector;
use crate::homestead_hearth::homestead_hearth;
use crate::wild_animal_npc::core::wild_animal;
use crate::coral::living_coral;

// --- Explosive Constants ---
pub const EXPLOSIVE_PLACEMENT_MAX_DISTANCE: f32 = 100.0;
pub const EXPLOSIVE_PLACEMENT_MAX_DISTANCE_SQUARED: f32 = EXPLOSIVE_PLACEMENT_MAX_DISTANCE * EXPLOSIVE_PLACEMENT_MAX_DISTANCE;

// Tier 1: Babushka's Surprise
// Buffed from 300 to 375 for better cost-efficiency vs T2
// With 20% dud chance + random fuse, T1 trades reliability for resource savings
pub const TIER1_STRUCTURE_DAMAGE: f32 = 375.0;
pub const TIER1_PLAYER_DAMAGE: f32 = 80.0;
pub const TIER1_BLAST_RADIUS: f32 = 150.0;
pub const TIER1_FUSE_MIN_SECS: f32 = 5.0;  // Very unreliable - 5-30 second range
pub const TIER1_FUSE_MAX_SECS: f32 = 30.0;
pub const TIER1_DUD_CHANCE: f32 = 0.2; // 20% dud chance

// Tier 2: Matriarch's Wrath
pub const TIER2_STRUCTURE_DAMAGE: f32 = 1_000.0;
pub const TIER2_PLAYER_DAMAGE: f32 = 150.0;
pub const TIER2_BLAST_RADIUS: f32 = 200.0;
pub const TIER2_FUSE_SECS: f32 = 10.0; // Consistent 10 seconds

// Detonation check interval
pub const EXPLOSIVE_DETONATION_CHECK_INTERVAL_SECS: u64 = 1; // Check every second

// --- Explosive Type Enum ---
#[derive(spacetimedb::SpacetimeType, Clone, Debug, PartialEq)]
pub enum ExplosiveType {
    BabushkaSurprise, // Tier 1
    MatriarchWrath,   // Tier 2
}

// --- Placed Explosive Table ---
#[table(name = placed_explosive, public)]
#[derive(Clone, Debug)]
pub struct PlacedExplosive {
    #[primary_key]
    #[auto_inc]
    pub id: u64,
    pub pos_x: f32,
    pub pos_y: f32,
    pub chunk_index: u32,
    pub explosive_type: ExplosiveType,
    pub placed_by: Identity,
    pub placed_at: Timestamp,
    pub armed_at: Option<Timestamp>, // When fuse starts (immediately upon placement)
    pub fuse_duration_secs: f32,
    pub detonates_at: Option<Timestamp>, // When it will explode (armed_at + fuse_duration)
    pub is_dud: bool, // True if this explosive failed to detonate (Tier 1 only)
    pub blast_radius: f32,
    pub structure_damage: f32,
    pub player_damage: f32,
}

// --- Explosive Detonation Check Schedule ---
#[table(name = explosive_detonation_schedule, scheduled(check_explosive_detonations))]
#[derive(Clone, Debug)]
pub struct ExplosiveDetonationSchedule {
    #[primary_key]
    #[auto_inc]
    pub id: u64,
    pub scheduled_at: ScheduleAt,
}

// --- Initialization ---
pub fn init_explosive_system(ctx: &ReducerContext) -> Result<(), String> {
    // Check if schedule already exists
    if ctx.db.explosive_detonation_schedule().iter().next().is_some() {
        log::info!("[ExplosiveInit] Detonation schedule already exists, skipping initialization");
        return Ok(());
    }

    // Schedule periodic detonation checks
    let check_interval = TimeDuration::from_micros(EXPLOSIVE_DETONATION_CHECK_INTERVAL_SECS as i64 * 1_000_000);
    
    crate::try_insert_schedule!(
        ctx.db.explosive_detonation_schedule(),
        ExplosiveDetonationSchedule {
            id: 0,
            scheduled_at: ScheduleAt::Interval(check_interval),
        },
        "Explosive detonation check"
    );

    log::info!("[ExplosiveInit] Explosive system initialized with detonation check interval of {} seconds", 
               EXPLOSIVE_DETONATION_CHECK_INTERVAL_SECS);
    Ok(())
}

// --- Placement Reducer ---
#[reducer]
pub fn place_explosive(ctx: &ReducerContext, item_instance_id: u64, world_x: f32, world_y: f32) -> Result<(), String> {
    let sender_id = ctx.sender;
    let inventory_items = ctx.db.inventory_item();
    let item_defs = ctx.db.item_definition();
    let players = ctx.db.player();
    let explosives = ctx.db.placed_explosive();

    // Look up explosive item definitions
    let babushka_def_id = item_defs.iter()
        .find(|def| def.name == "Babushka's Surprise")
        .map(|def| def.id)
        .ok_or_else(|| "Item definition for 'Babushka's Surprise' not found.".to_string())?;

    let matriarch_def_id = item_defs.iter()
        .find(|def| def.name == "Matriarch's Wrath")
        .map(|def| def.id)
        .ok_or_else(|| "Item definition for 'Matriarch's Wrath' not found.".to_string())?;

    log::info!(
        "[PlaceExplosive] Player {:?} attempting placement of item {} at ({:.1}, {:.1})",
        sender_id, item_instance_id, world_x, world_y
    );

    // Check if position is within monument zones
    crate::building::check_monument_zone_placement(ctx, world_x, world_y)?;

    // Validate player
    let player = players.identity().find(sender_id)
        .ok_or_else(|| "Player not found".to_string())?;

    if player.is_dead {
        return Err("Cannot place explosive while dead.".to_string());
    }
    if player.is_knocked_out {
        return Err("Cannot place explosive while knocked out.".to_string());
    }

    // Check placement distance
    let dx_place = world_x - player.position_x;
    let dy_place = world_y - player.position_y;
    let dist_sq_place = dx_place * dx_place + dy_place * dy_place;
    if dist_sq_place > EXPLOSIVE_PLACEMENT_MAX_DISTANCE_SQUARED {
        return Err(format!("Cannot place explosive too far away ({} > {}).",
                dist_sq_place.sqrt(), EXPLOSIVE_PLACEMENT_MAX_DISTANCE));
    }

    // Check if placement position is on a wall
    if crate::building::is_position_on_wall(ctx, world_x, world_y) {
        return Err("Cannot place explosive on a wall.".to_string());
    }

    // Check if placement position is on water
    let tile_x = (world_x / crate::TILE_SIZE_PX as f32).floor() as i32;
    let tile_y = (world_y / crate::TILE_SIZE_PX as f32).floor() as i32;
    if let Some(tile_type) = crate::get_tile_type_at_position(ctx, tile_x, tile_y) {
        if tile_type.is_water() {
            return Err("Cannot place explosive on water.".to_string());
        }
    }

    // Check collision with other explosives
    for other_explosive in explosives.iter() {
        let dx = world_x - other_explosive.pos_x;
        let dy = world_y - other_explosive.pos_y;
        let dist_sq = dx * dx + dy * dy;
        if dist_sq < 100.0 * 100.0 { // 100 pixel minimum distance
            return Err("Cannot place explosive too close to another explosive.".to_string());
        }
    }

    // Find the item instance and validate
    let item_to_consume = inventory_items.instance_id().find(item_instance_id)
        .ok_or_else(|| format!("Item instance {} not found.", item_instance_id))?;

    // Validate ownership (use ref to avoid partial move)
    match &item_to_consume.location {
        ItemLocation::Inventory(data) => {
            if data.owner_id != sender_id {
                return Err(format!("Item instance {} not owned by player {:?}.", item_instance_id, sender_id));
            }
        }
        ItemLocation::Hotbar(data) => {
            if data.owner_id != sender_id {
                return Err(format!("Item instance {} not owned by player {:?}.", item_instance_id, sender_id));
            }
        }
        _ => {
            return Err(format!("Item instance {} is not in player inventory or hotbar.", item_instance_id));
        }
    }

    // Determine explosive type and stats
    let (explosive_type, fuse_duration, blast_radius, structure_damage, player_damage) = if item_to_consume.item_def_id == babushka_def_id {
        // Tier 1: Random fuse time, dud chance
        let fuse_duration = ctx.rng().gen_range(TIER1_FUSE_MIN_SECS..=TIER1_FUSE_MAX_SECS);
        (
            ExplosiveType::BabushkaSurprise,
            fuse_duration,
            TIER1_BLAST_RADIUS,
            TIER1_STRUCTURE_DAMAGE,
            TIER1_PLAYER_DAMAGE,
        )
    } else if item_to_consume.item_def_id == matriarch_def_id {
        // Tier 2: Fixed fuse time, no dud chance
        (
            ExplosiveType::MatriarchWrath,
            TIER2_FUSE_SECS,
            TIER2_BLAST_RADIUS,
            TIER2_STRUCTURE_DAMAGE,
            TIER2_PLAYER_DAMAGE,
        )
    } else {
        return Err(format!("Item instance {} is not an explosive (expected def {} or {}, got {}).",
                        item_instance_id, babushka_def_id, matriarch_def_id, item_to_consume.item_def_id));
    };

    // Consume ONE item from the stack (not the entire stack)
    log::info!(
        "[PlaceExplosive] Consuming 1 of {} item(s) from instance {} (Def ID: {}) from player {:?}",
        item_to_consume.quantity, item_instance_id, item_to_consume.item_def_id, sender_id
    );
    if item_to_consume.quantity > 1 {
        let mut updated_item = item_to_consume.clone();
        updated_item.quantity -= 1;
        inventory_items.instance_id().update(updated_item);
    } else {
        inventory_items.instance_id().delete(item_instance_id);
    }

    // Create explosive entity - fuse starts immediately
    let current_time = ctx.timestamp;
    
    // Calculate detonation time (placed_at + fuse duration)
    let fuse_duration_td = TimeDuration::from_micros((fuse_duration * 1_000_000.0) as i64);
    let detonates_at = current_time + fuse_duration_td;

    let chunk_idx = calculate_chunk_index(world_x, world_y);

    let new_explosive = PlacedExplosive {
        id: 0, // Auto-incremented
        pos_x: world_x,
        pos_y: world_y,
        chunk_index: chunk_idx,
        explosive_type: explosive_type.clone(),
        placed_by: sender_id,
        placed_at: current_time,
        armed_at: Some(current_time), // Fuse starts immediately
        fuse_duration_secs: fuse_duration,
        detonates_at: Some(detonates_at),
        is_dud: false, // Will be set during detonation check if Tier 1 fails
        blast_radius,
        structure_damage,
        player_damage,
    };

    let inserted_explosive = explosives.try_insert(new_explosive)
        .map_err(|e| format!("Failed to insert explosive: {}", e))?;

    log::info!(
        "[PlaceExplosive] Player {} placed {} explosive {} at ({:.1}, {:.1}). Fuse: {:.1}s",
        player.username, 
        match explosive_type {
            ExplosiveType::BabushkaSurprise => "Babushka's Surprise",
            ExplosiveType::MatriarchWrath => "Matriarch's Wrath",
        },
        inserted_explosive.id,
        world_x, world_y,
        fuse_duration
    );

    // Start looping fuse sound (continuous sound that will stop when explosive detonates)
    crate::sound_events::start_explosive_fuse_sound(ctx, inserted_explosive.id, world_x, world_y);

    Ok(())
}

// --- Scheduled Detonation Check Reducer ---
#[reducer]
pub fn check_explosive_detonations(ctx: &ReducerContext, _schedule: ExplosiveDetonationSchedule) {
    // PERFORMANCE: Early exit if no placed explosives exist
    let explosives = ctx.db.placed_explosive();
    if explosives.iter().next().is_none() {
        return;
    }
    
    let current_time = ctx.timestamp;
    
    // Collect explosives that should detonate
    let mut explosives_to_detonate: Vec<u64> = Vec::new();
    
    for explosive in explosives.iter() {
        // Skip if not armed yet (shouldn't happen now, but keep check)
        if explosive.armed_at.is_none() {
            continue;
        }
        
        // Skip if already a dud
        if explosive.is_dud {
            continue;
        }
        
        // Check if this explosive should detonate
        if let Some(detonates_at) = explosive.detonates_at {
            if current_time >= detonates_at {
                // Time to detonate
                explosives_to_detonate.push(explosive.id);
            }
            // Note: Fuse sound is handled via ContinuousSound - no need to emit every second
        }
    }
    
    // Detonate each explosive
    for explosive_id in explosives_to_detonate {
        if let Some(explosive) = explosives.id().find(explosive_id) {
            detonate_explosive(ctx, explosive);
        }
    }
}

// --- Detonation Function ---
fn detonate_explosive(ctx: &ReducerContext, explosive: PlacedExplosive) {
    log::info!(
        "[DetonateExplosive] Explosive {} ({:?}) detonating at ({:.1}, {:.1})",
        explosive.id, explosive.explosive_type, explosive.pos_x, explosive.pos_y
    );
    
    // Check for dud (Tier 1 only)
    if matches!(explosive.explosive_type, ExplosiveType::BabushkaSurprise) {
        let dud_roll: f32 = ctx.rng().gen();
        if dud_roll < TIER1_DUD_CHANCE {
            // Mark as dud - can be re-lit
            let mut dud_explosive = explosive.clone();
            dud_explosive.is_dud = true;
            dud_explosive.detonates_at = None; // Clear detonation time
            ctx.db.placed_explosive().id().update(dud_explosive);
            
            // Stop the fuse sound when it fizzles
            crate::sound_events::stop_explosive_fuse_sound(ctx, explosive.id);
            
            log::info!("[DetonateExplosive] Explosive {} was a dud! Can be re-lit.", explosive.id);
            crate::sound_events::emit_explosive_dud_sound(ctx, explosive.pos_x, explosive.pos_y, explosive.placed_by);
            return;
        }
    }
    
    // Apply explosion damage
    apply_explosion_damage(ctx, &explosive);
    
    // Stop the fuse sound (continuous sound created when explosive was placed)
    crate::sound_events::stop_explosive_fuse_sound(ctx, explosive.id);
    
    // Emit explosion sound
    crate::sound_events::emit_explosion_sound(ctx, explosive.pos_x, explosive.pos_y, explosive.placed_by);
    
    // Delete the explosive entity
    ctx.db.placed_explosive().id().delete(explosive.id);
}

// --- Explosion Damage Function ---
fn apply_explosion_damage(ctx: &ReducerContext, explosive: &PlacedExplosive) {
    let blast_radius_sq = explosive.blast_radius * explosive.blast_radius;
    
    // Damage structures (walls, doors, foundations)
    damage_structures_in_radius(ctx, explosive.pos_x, explosive.pos_y, explosive.blast_radius, blast_radius_sq, explosive.structure_damage);
    
    // Damage placeables (furnaces, boxes, lanterns, stashes, etc.)
    damage_placeables_in_radius(ctx, explosive.pos_x, explosive.pos_y, explosive.blast_radius, blast_radius_sq, explosive.structure_damage);
    
    // Damage natural resources (trees, stones, grass, barrels, coral)
    damage_resources_in_radius(ctx, explosive.pos_x, explosive.pos_y, explosive.blast_radius, blast_radius_sq, explosive.structure_damage);
    
    // Damage wild animals
    damage_animals_in_radius(ctx, explosive.pos_x, explosive.pos_y, explosive.blast_radius, blast_radius_sq, explosive.player_damage);
    
    // Damage players (friendly fire!)
    damage_players_in_radius(ctx, explosive.pos_x, explosive.pos_y, explosive.blast_radius, blast_radius_sq, explosive.player_damage);
}

// --- Structure Damage ---
fn damage_structures_in_radius(ctx: &ReducerContext, center_x: f32, center_y: f32, radius: f32, radius_sq: f32, damage: f32) {
    use crate::building::FOUNDATION_TILE_SIZE_PX;
    
    // Damage walls
    for wall in ctx.db.wall_cell().iter() {
        // Convert cell coordinates to world coordinates
        let wall_world_x = (wall.cell_x as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
        let wall_world_y = (wall.cell_y as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
        
        let dx = wall_world_x - center_x;
        let dy = wall_world_y - center_y;
        let dist_sq = dx * dx + dy * dy;
        
        if dist_sq <= radius_sq {
            // Explosive damage bypasses melee reduction
            crate::building::damage_wall_explosive(ctx, wall.id, damage);
        }
    }
    
    // Damage doors
    for door in ctx.db.door().iter() {
        let dx = door.pos_x - center_x;
        let dy = door.pos_y - center_y;
        let dist_sq = dx * dx + dy * dy;
        
        if dist_sq <= radius_sq {
            crate::door::damage_door_explosive(ctx, door.id, damage);
        }
    }
    
    // Damage foundations
    for foundation in ctx.db.foundation_cell().iter() {
        // Convert cell coordinates to world coordinates
        let foundation_world_x = (foundation.cell_x as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
        let foundation_world_y = (foundation.cell_y as f32 * FOUNDATION_TILE_SIZE_PX as f32) + (FOUNDATION_TILE_SIZE_PX as f32 / 2.0);
        
        let dx = foundation_world_x - center_x;
        let dy = foundation_world_y - center_y;
        let dist_sq = dx * dx + dy * dy;
        
        if dist_sq <= radius_sq {
            crate::building::damage_foundation_explosive(ctx, foundation.id, damage);
        }
    }
}

// --- Placeable Damage ---
fn damage_placeables_in_radius(ctx: &ReducerContext, center_x: f32, center_y: f32, _radius: f32, radius_sq: f32, damage: f32) {
    let current_time = ctx.timestamp;
    let attacker_id = ctx.sender; // Use explosive placer as attacker
    let mut rng = ctx.rng();
    
    // Damage campfires
    for campfire in ctx.db.campfire().iter() {
        let dx = campfire.pos_x - center_x;
        let dy = campfire.pos_y - center_y;
        let dist_sq = dx * dx + dy * dy;
        
        if dist_sq <= radius_sq {
            let _ = crate::combat::damage_campfire(ctx, attacker_id, campfire.id, damage, current_time, &mut rng);
        }
    }
    
    // Damage furnaces
    for furnace in ctx.db.furnace().iter() {
        let dx = furnace.pos_x - center_x;
        let dy = furnace.pos_y - center_y;
        let dist_sq = dx * dx + dy * dy;
        
        if dist_sq <= radius_sq {
            let _ = crate::combat::damage_furnace(ctx, attacker_id, furnace.id, damage, current_time, &mut rng);
        }
    }
    
    // Damage storage boxes
    for storage_box in ctx.db.wooden_storage_box().iter() {
        let dx = storage_box.pos_x - center_x;
        let dy = storage_box.pos_y - center_y;
        let dist_sq = dx * dx + dy * dy;
        
        if dist_sq <= radius_sq {
            let _ = crate::combat::damage_wooden_storage_box(ctx, attacker_id, storage_box.id, damage, current_time, &mut rng);
        }
    }
    
    // Damage shelters
    for shelter in ctx.db.shelter().iter() {
        let dx = shelter.pos_x - center_x;
        let dy = shelter.pos_y - center_y;
        let dist_sq = dx * dx + dy * dy;
        
        if dist_sq <= radius_sq {
            let _ = crate::shelter::damage_shelter(ctx, attacker_id, shelter.id, damage, current_time, &mut rng);
        }
    }
    
    // Damage lanterns
    for lantern in ctx.db.lantern().iter() {
        let dx = lantern.pos_x - center_x;
        let dy = lantern.pos_y - center_y;
        let dist_sq = dx * dx + dy * dy;
        
        if dist_sq <= radius_sq {
            let _ = crate::combat::damage_lantern(ctx, attacker_id, lantern.id, damage, current_time, &mut rng);
        }
    }
    
    // Damage stashes
    for stash in ctx.db.stash().iter() {
        let dx = stash.pos_x - center_x;
        let dy = stash.pos_y - center_y;
        let dist_sq = dx * dx + dy * dy;
        
        if dist_sq <= radius_sq {
            let _ = crate::combat::damage_stash(ctx, attacker_id, stash.id, damage, current_time, &mut rng);
        }
    }
    
    // Damage sleeping bags
    for bag in ctx.db.sleeping_bag().iter() {
        let dx = bag.pos_x - center_x;
        let dy = bag.pos_y - center_y;
        let dist_sq = dx * dx + dy * dy;
        
        if dist_sq <= radius_sq {
            let _ = crate::combat::damage_sleeping_bag(ctx, attacker_id, bag.id, damage, current_time, &mut rng);
        }
    }
    
    // Damage rain collectors
    for collector in ctx.db.rain_collector().iter() {
        let dx = collector.pos_x - center_x;
        let dy = collector.pos_y - center_y;
        let dist_sq = dx * dx + dy * dy;
        
        if dist_sq <= radius_sq {
            let _ = crate::combat::damage_rain_collector(ctx, attacker_id, collector.id, damage, current_time, &mut rng);
        }
    }
    
    // Damage hearths
    for hearth in ctx.db.homestead_hearth().iter() {
        let dx = hearth.pos_x - center_x;
        let dy = hearth.pos_y - center_y;
        let dist_sq = dx * dx + dy * dy;
        
        if dist_sq <= radius_sq {
            let _ = crate::homestead_hearth::damage_hearth(ctx, attacker_id, hearth.id, damage, current_time);
        }
    }
}

// --- Natural Resource Damage (Trees, Stones, Grass, Barrels, Coral) ---
fn damage_resources_in_radius(ctx: &ReducerContext, center_x: f32, center_y: f32, _radius: f32, radius_sq: f32, damage: f32) {
    let current_time = ctx.timestamp;
    let attacker_id = ctx.sender;
    let mut rng = ctx.rng();
    
    // Damage trees
    let trees_to_damage: Vec<u64> = ctx.db.tree().iter()
        .filter(|tree| {
            let dx = tree.pos_x - center_x;
            let dy = tree.pos_y - center_y;
            let dist_sq = dx * dx + dy * dy;
            dist_sq <= radius_sq && tree.health > 0
        })
        .map(|tree| tree.id)
        .collect();
    
    for tree_id in trees_to_damage {
        // Trees give Wood when damaged by explosives
        let _ = crate::combat::damage_tree(ctx, attacker_id, tree_id, damage, 0, "Wood", current_time, &mut rng);
    }
    
    // Damage stones
    let stones_to_damage: Vec<u64> = ctx.db.stone().iter()
        .filter(|stone| {
            let dx = stone.pos_x - center_x;
            let dy = stone.pos_y - center_y;
            let dist_sq = dx * dx + dy * dy;
            dist_sq <= radius_sq && stone.health > 0
        })
        .map(|stone| stone.id)
        .collect();
    
    for stone_id in stones_to_damage {
        // Stones give their respective ore when damaged
        let _ = crate::combat::damage_stone(ctx, attacker_id, stone_id, damage, 0, "Stone", current_time, &mut rng);
    }
    
    // Damage grass blades (instant destroy - grass has 1 HP)
    let grass_to_destroy: Vec<(u64, f32, f32, crate::grass::GrassAppearanceType, u32, u32, f32)> = ctx.db.grass().iter()
        .filter(|grass| {
            // Skip brambles (indestructible)
            if grass.appearance_type.is_bramble() {
                return false;
            }
            let dx = grass.pos_x - center_x;
            let dy = grass.pos_y - center_y;
            let dist_sq = dx * dx + dy * dy;
            dist_sq <= radius_sq && grass.health > 0
        })
        .map(|grass| (grass.id, grass.pos_x, grass.pos_y, grass.appearance_type.clone(), grass.chunk_index, grass.sway_offset_seed, grass.sway_speed))
        .collect();
    
    for (grass_id, pos_x, pos_y, appearance_type, chunk_index, sway_offset_seed, sway_speed) in grass_to_destroy {
        // Schedule respawn
        let respawn_secs = rng.gen_range(MIN_GRASS_RESPAWN_TIME_SECS..=MAX_GRASS_RESPAWN_TIME_SECS);
        let respawn_time = current_time + spacetimedb::TimeDuration::from_micros(respawn_secs as i64 * 1_000_000);
        
        let respawn_data = GrassRespawnData {
            pos_x,
            pos_y,
            appearance_type,
            chunk_index,
            sway_offset_seed,
            sway_speed,
        };
        
        let _ = ctx.db.grass_respawn_schedule().try_insert(GrassRespawnSchedule {
            schedule_id: 0,
            respawn_data,
            scheduled_at: spacetimedb::ScheduleAt::Time(respawn_time),
        });
        
        // Delete the grass
        ctx.db.grass().id().delete(grass_id);
    }
    
    // Damage barrels
    let barrels_to_damage: Vec<u64> = ctx.db.barrel().iter()
        .filter(|barrel| {
            let dx = barrel.pos_x - center_x;
            let dy = barrel.pos_y - center_y;
            let dist_sq = dx * dx + dy * dy;
            dist_sq <= radius_sq && barrel.health > 0.0
        })
        .map(|barrel| barrel.id)
        .collect();
    
    for barrel_id in barrels_to_damage {
        let _ = crate::barrel::damage_barrel(ctx, attacker_id, barrel_id, damage, current_time, &mut rng);
    }
    
    // Damage living coral
    let corals_to_damage: Vec<u64> = ctx.db.living_coral().iter()
        .filter(|coral| {
            let dx = coral.pos_x - center_x;
            let dy = coral.pos_y - center_y;
            let dist_sq = dx * dx + dy * dy;
            dist_sq <= radius_sq && coral.health > 0
        })
        .map(|coral| coral.id)
        .collect();
    
    for coral_id in corals_to_damage {
        let _ = crate::combat::damage_living_coral(ctx, attacker_id, coral_id, damage, 0, current_time, &mut rng);
    }
}

// --- Wild Animal Damage ---
fn damage_animals_in_radius(ctx: &ReducerContext, center_x: f32, center_y: f32, _radius: f32, radius_sq: f32, damage: f32) {
    let attacker_id = ctx.sender;
    
    // Damage wild animals
    let animals_to_damage: Vec<u64> = ctx.db.wild_animal().iter()
        .filter(|animal| {
            let dx = animal.pos_x - center_x;
            let dy = animal.pos_y - center_y;
            let dist_sq = dx * dx + dy * dy;
            dist_sq <= radius_sq && animal.health > 0.0
        })
        .map(|animal| animal.id)
        .collect();
    
    for animal_id in animals_to_damage {
        let _ = crate::wild_animal_npc::core::damage_wild_animal(ctx, animal_id, damage, attacker_id);
    }
}

// --- Player Damage (Friendly Fire) ---
fn damage_players_in_radius(ctx: &ReducerContext, center_x: f32, center_y: f32, radius: f32, radius_sq: f32, damage: f32) {
    let attacker_id = ctx.sender;
    let current_time = ctx.timestamp;
    
    // Create a dummy item definition for explosion damage
    // We'll use a simple melee weapon definition as a placeholder
    let item_defs = ctx.db.item_definition();
    let explosion_item_def = item_defs.iter()
        .find(|def| def.name == "Stone Spear") // Use any weapon as placeholder
        .or_else(|| item_defs.iter().next());
    
    if let Some(item_def) = explosion_item_def {
        for player in ctx.db.player().iter() {
            if player.is_dead {
                continue;
            }
            
            let dx = player.position_x - center_x;
            let dy = player.position_y - center_y;
            let dist_sq = dx * dx + dy * dy;
            
            if dist_sq <= radius_sq {
                // Apply damage to player (friendly fire!)
                let _ = crate::combat::damage_player(ctx, attacker_id, player.identity, damage, &item_def, current_time);
                
                log::info!(
                    "[ExplosionDamage] Player {} took {} explosion damage at distance {:.1}",
                    player.username, damage, dist_sq.sqrt()
                );
            }
        }
    }
}

// --- Re-light Dud Explosive Reducer ---
#[reducer]
pub fn relight_dud_explosive(ctx: &ReducerContext, explosive_id: u64) -> Result<(), String> {
    let sender_id = ctx.sender;
    let explosives = ctx.db.placed_explosive();
    
    let explosive = explosives.id().find(explosive_id)
        .ok_or_else(|| format!("Explosive {} not found.", explosive_id))?;
    
    if !explosive.is_dud {
        return Err("This explosive is not a dud.".to_string());
    }
    
    // Check if player is close enough
    let player = ctx.db.player().identity().find(sender_id)
        .ok_or_else(|| "Player not found".to_string())?;
    
    let dx = explosive.pos_x - player.position_x;
    let dy = explosive.pos_y - player.position_y;
    let dist_sq = dx * dx + dy * dy;
    
    if dist_sq > 100.0 * 100.0 { // 100 pixel interaction distance
        return Err("Too far away to re-light explosive.".to_string());
    }
    
    // Re-light: roll for dud chance again
    let dud_roll: f32 = ctx.rng().gen();
    if dud_roll < TIER1_DUD_CHANCE {
        // Still a dud
        log::info!("[RelightDud] Explosive {} still a dud after re-light attempt.", explosive_id);
        crate::sound_events::emit_explosive_dud_sound(ctx, explosive.pos_x, explosive.pos_y, sender_id);
        return Ok(());
    }
    
    // Successfully re-lit - set new detonation time (fuse starts immediately)
    let current_time = ctx.timestamp;
    let fuse_duration_td = TimeDuration::from_micros((explosive.fuse_duration_secs * 1_000_000.0) as i64);
    let detonates_at = current_time + fuse_duration_td;
    
    let mut relit_explosive = explosive.clone();
    relit_explosive.is_dud = false;
    relit_explosive.armed_at = Some(current_time); // Fuse starts immediately
    relit_explosive.detonates_at = Some(detonates_at);
    
    ctx.db.placed_explosive().id().update(relit_explosive);
    
    log::info!("[RelightDud] Explosive {} successfully re-lit! Will detonate in {:.1}s", explosive_id, explosive.fuse_duration_secs);
    
    // Start looping fuse sound again
    crate::sound_events::start_explosive_fuse_sound(ctx, explosive_id, explosive.pos_x, explosive.pos_y);
    
    Ok(())
}