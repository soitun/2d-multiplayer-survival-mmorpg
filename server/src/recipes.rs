/******************************************************************************
 *                                                                            *
 * Recipe System for Broth Pot Cooking                                       *
 *                                                                            *
 * Defines recipe structures, matching logic, and recipe registry.            *
 * Supports both hardcoded and AI-generated recipes.                          *
 *                                                                            *
 ******************************************************************************/

use spacetimedb::{ReducerContext, log, Table};
use crate::broth_pot::BrothPot;
use crate::sound_events;
use crate::items::item_definition as ItemDefinitionTableTrait;
use crate::items::inventory_item as InventoryItemTableTrait;

/// Recipe tier information - defines how recipe output changes based on ingredient count
#[derive(Clone, Debug)]
pub struct RecipeTier {
    pub min_ingredient_count: u32, // Minimum count of primary ingredient for this tier
    pub output_name: String,        // Output item name for this tier
    pub cooking_time_secs: f32,     // Cooking time in seconds
}

/// Recipe definition - can represent both hardcoded and AI-generated recipes
#[derive(Clone, Debug)]
pub struct Recipe {
    pub name: String,                    // Recipe name (e.g., "Stone Soup")
    pub primary_ingredient: String,      // Primary ingredient name (e.g., "Stone")
    pub required_ingredients: Vec<String>, // All required ingredient names (for future multi-ingredient recipes)
    pub tiers: Vec<RecipeTier>,         // Recipe tiers based on ingredient count
    pub is_ai_generated: bool,          // True if generated by AI, false if hardcoded
}

/// Recipe match result - contains matched recipe and tier information
#[derive(Clone, Debug)]
pub struct RecipeMatch {
    pub recipe: Recipe,
    pub tier: RecipeTier,
    pub matched_ingredient_count: u32,
}

/// Recipe registry - returns all available recipes (hardcoded + AI)
pub fn get_all_recipes() -> Vec<Recipe> {
    let mut recipes = Vec::new();
    
    // Add hardcoded recipes
    recipes.push(get_stone_soup_recipe());
    
    // TODO: Add AI-generated recipes from cache here
    // let ai_recipes = get_ai_recipes_from_cache();
    // recipes.extend(ai_recipes);
    
    recipes
}

/// Get the Stone Soup recipe definition
fn get_stone_soup_recipe() -> Recipe {
    Recipe {
        name: "Stone Soup".to_string(),
        primary_ingredient: "Stone".to_string(),
        required_ingredients: vec!["Stone".to_string()],
        tiers: vec![
            RecipeTier {
                min_ingredient_count: 1,
                output_name: "Stone Soup".to_string(),
                cooking_time_secs: 60.0,
            },
            RecipeTier {
                min_ingredient_count: 2,
                output_name: "Hearty Stone Soup".to_string(),
                cooking_time_secs: 90.0,
            },
            RecipeTier {
                min_ingredient_count: 3,
                output_name: "Gourmet Stone Soup".to_string(),
                cooking_time_secs: 120.0,
            },
        ],
        is_ai_generated: false,
    }
}

/// Collect ingredient names from a broth pot
/// Only returns names for items that actually exist (not deleted/consumed)
pub fn collect_ingredient_names(ctx: &ReducerContext, broth_pot: &BrothPot) -> Result<Vec<String>, String> {
    let item_defs = ctx.db.item_definition();
    let items = ctx.db.inventory_item();
    let mut ingredient_names = Vec::new();
    
    let ingredient_slots = [
        (broth_pot.ingredient_instance_id_0, broth_pot.ingredient_def_id_0),
        (broth_pot.ingredient_instance_id_1, broth_pot.ingredient_def_id_1),
        (broth_pot.ingredient_instance_id_2, broth_pot.ingredient_def_id_2),
    ];
    
    for (instance_id_opt, def_id_opt) in ingredient_slots.iter() {
        if let (Some(instance_id), Some(def_id)) = (instance_id_opt, def_id_opt) {
            // CRITICAL: Check if the item actually exists (it might have been consumed/deleted)
            if let Some(_item) = items.instance_id().find(instance_id) {
                if let Some(item_def) = item_defs.id().find(def_id) {
                    ingredient_names.push(item_def.name.clone());
                }
            }
        }
    }
    
    Ok(ingredient_names)
}

/// Count occurrences of a specific ingredient in a broth pot
/// Counts the total QUANTITY of items across all slots, not just number of slots
pub fn count_ingredient(ctx: &ReducerContext, broth_pot: &BrothPot, ingredient_name: &str) -> u32 {
    let item_defs = ctx.db.item_definition();
    let items = ctx.db.inventory_item();
    let mut count = 0;
    
    let ingredient_slots = [
        (broth_pot.ingredient_instance_id_0, broth_pot.ingredient_def_id_0),
        (broth_pot.ingredient_instance_id_1, broth_pot.ingredient_def_id_1),
        (broth_pot.ingredient_instance_id_2, broth_pot.ingredient_def_id_2),
    ];
    
    for (instance_id_opt, def_id_opt) in ingredient_slots.iter() {
        if let (Some(instance_id), Some(def_id)) = (instance_id_opt, def_id_opt) {
            // CRITICAL: Check if the item actually exists (it might have been consumed/deleted)
            if let Some(item) = items.instance_id().find(instance_id) {
                if let Some(item_def) = item_defs.id().find(def_id) {
                    if item_def.name == ingredient_name {
                        // Count the actual quantity, not just the slot
                        count += item.quantity;
                    }
                }
            }
        }
    }
    
    count
}

/// Match ingredients in a broth pot against available recipes
/// Returns the best matching recipe and tier, or None if no match
pub fn match_recipe(ctx: &ReducerContext, broth_pot: &BrothPot) -> Option<RecipeMatch> {
    let recipes = get_all_recipes();
    let ingredient_names = collect_ingredient_names(ctx, broth_pot).ok()?;
    
    log::info!("[RecipeMatcher] Pot {} has ingredients: {:?}", broth_pot.id, ingredient_names);
    
    // Try each recipe
    for recipe in recipes {
        // Check if all required ingredients are present
        let mut has_all_required = true;
        for required in &recipe.required_ingredients {
            if !ingredient_names.contains(required) {
                has_all_required = false;
                break;
            }
        }
        
        if !has_all_required {
            continue;
        }
        
        // Count primary ingredient occurrences
        let primary_count = count_ingredient(ctx, broth_pot, &recipe.primary_ingredient);
        
        log::info!("[RecipeMatcher] Recipe '{}' primary ingredient '{}' count: {}", 
                   recipe.name, recipe.primary_ingredient, primary_count);
        
        if primary_count == 0 {
            continue;
        }
        
        // Find the highest tier that matches the ingredient count
        // Tiers should be sorted by min_ingredient_count ascending
        let mut best_tier: Option<&RecipeTier> = None;
        for tier in &recipe.tiers {
            if primary_count >= tier.min_ingredient_count {
                if let Some(current_best) = best_tier {
                    if tier.min_ingredient_count > current_best.min_ingredient_count {
                        best_tier = Some(tier);
                    }
                } else {
                    best_tier = Some(tier);
                }
            }
        }
        
        if let Some(tier) = best_tier {
            log::info!("[RecipeMatcher] ✓ Matched recipe '{}' tier '{}' (needs {} ingredients, have {})", 
                       recipe.name, tier.output_name, tier.min_ingredient_count, primary_count);
            return Some(RecipeMatch {
                recipe: recipe.clone(),
                tier: tier.clone(),
                matched_ingredient_count: primary_count,
            });
        }
    }
    
    log::warn!("[RecipeMatcher] ✗ No recipe matched for pot {}", broth_pot.id);
    None
}

/// Start brewing a recipe in a broth pot
pub fn start_brewing_recipe(
    ctx: &ReducerContext,
    broth_pot: &mut BrothPot,
    recipe_match: &RecipeMatch,
    broth_pot_id: u32,
) -> Result<(), String> {
    broth_pot.is_cooking = true;
    broth_pot.current_recipe_name = Some(recipe_match.tier.output_name.clone());
    broth_pot.required_cooking_time_secs = recipe_match.tier.cooking_time_secs;
    broth_pot.cooking_progress_secs = 0.0;
    
    // Start boiling sound
    sound_events::start_soup_boiling_sound(ctx, broth_pot_id, broth_pot.pos_x, broth_pot.pos_y);
    
    log::info!(
        "[BrothPot] Started brewing {} (tier: {} ingredients) in pot {}",
        recipe_match.tier.output_name,
        recipe_match.matched_ingredient_count,
        broth_pot_id
    );
    
    Ok(())
}

